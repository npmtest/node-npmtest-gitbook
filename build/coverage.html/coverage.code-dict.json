{"/home/travis/build/npmtest/node-npmtest-gitbook/test.js":"/* istanbul instrument in package npmtest_gitbook */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-gitbook/lib.npmtest_gitbook.js":"/* istanbul instrument in package npmtest_gitbook */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_gitbook = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_gitbook = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-gitbook/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-gitbook && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_gitbook */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_gitbook\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_gitbook.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_gitbook.rollup.js'] =\n            local.assetsDict['/assets.npmtest_gitbook.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_gitbook.__dirname +\n                    '/lib.npmtest_gitbook.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/index.js":"var extend = require('extend');\n\nvar common = require('./browser');\n\nmodule.exports = extend({\n    initBook:       require('./init'),\n    createNodeFS:   require('./fs/node'),\n    Output:         require('./output'),\n    commands:       require('./cli')\n}, common);\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/browser.js":"var Modifiers = require('./modifiers');\n\nmodule.exports = {\n    Parse:              require('./parse'),\n\n    // Models\n    Book:               require('./models/book'),\n    FS:                 require('./models/fs'),\n    File:               require('./models/file'),\n    Summary:            require('./models/summary'),\n    Glossary:           require('./models/glossary'),\n    Config:             require('./models/config'),\n    Page:               require('./models/page'),\n    PluginDependency:   require('./models/pluginDependency'),\n\n    // Modifiers\n    SummaryModifier:    Modifiers.Summary,\n    ConfigModifier:     Modifiers.Config,\n\n    // Constants\n    CONFIG_FILES:        require('./constants/configFiles.js'),\n    IGNORE_FILES:        require('./constants/ignoreFiles.js'),\n    DEFAULT_PLUGINS:     require('./constants/defaultPlugins'),\n    EXTENSIONS_MARKDOWN: require('./constants/extsMarkdown'),\n    EXTENSIONS_ASCIIDOC: require('./constants/extsAsciidoc')\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/index.js":"\nmodule.exports = {\n    Summary:        require('./summary'),\n    Config:         require('./config')\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/index.js":"module.exports = {\n    insertArticle:      require('./insertArticle'),\n    moveArticle:        require('./moveArticle'),\n    moveArticleAfter:   require('./moveArticleAfter'),\n    removeArticle:      require('./removeArticle'),\n    unshiftArticle:     require('./unshiftArticle'),\n    editArticleTitle:   require('./editArticleTitle'),\n    editArticleRef:     require('./editArticleRef'),\n\n    insertPart:         require('./insertPart'),\n    removePart:         require('./removePart'),\n    editPartTitle:      require('./editPartTitle')\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/insertArticle.js":"var is = require('is');\nvar SummaryArticle = require('../../models/summaryArticle');\nvar mergeAtLevel = require('./mergeAtLevel');\nvar indexArticleLevels = require('./indexArticleLevels');\n\n/**\n    Returns a new Summary with the article at the given level, with\n    subsequent article shifted.\n\n    @param {Summary} summary\n    @param {Article} article\n    @param {String|Article} level: level to insert at\n    @return {Summary}\n*/\nfunction insertArticle(summary, article, level) {\n    article = SummaryArticle(article);\n    level = is.string(level)? level : level.getLevel();\n\n    var parent = summary.getParent(level);\n    if (!parent) {\n        return summary;\n    }\n\n    // Find the index to insert at\n    var articles = parent.getArticles();\n    var index = getLeafIndex(level);\n\n    // Insert the article at the right index\n    articles = articles.insert(index, article);\n\n    // Reindex the level from here\n    parent = parent.set('articles', articles);\n    parent = indexArticleLevels(parent);\n\n    return mergeAtLevel(summary, parent.getLevel(), parent);\n}\n\n/**\n    @param {String}\n    @return {Number} The index of this level within its parent's children\n */\nfunction getLeafIndex(level) {\n    var arr = level.split('.').map(function (char) {\n        return parseInt(char, 10);\n    });\n    return arr[arr.length - 1] - 1;\n}\n\nmodule.exports = insertArticle;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/summaryArticle.js":"var Immutable = require('immutable');\n\nvar location = require('../utils/location');\n\n/*\n    An article represents an entry in the Summary / table of Contents\n*/\n\nvar SummaryArticle = Immutable.Record({\n    level:      String(),\n    title:      String(),\n    ref:        String(),\n    articles:   Immutable.List()\n}, 'SummaryArticle');\n\nSummaryArticle.prototype.getLevel = function() {\n    return this.get('level');\n};\n\nSummaryArticle.prototype.getTitle = function() {\n    return this.get('title');\n};\n\nSummaryArticle.prototype.getRef = function() {\n    return this.get('ref');\n};\n\nSummaryArticle.prototype.getArticles = function() {\n    return this.get('articles');\n};\n\n/**\n * Return how deep the article is.\n * The README has a depth of 1\n *\n * @return {Number}\n */\nSummaryArticle.prototype.getDepth = function() {\n    return (this.getLevel().split('.').length - 1);\n};\n\n/**\n * Get path (without anchor) to the pointing file.\n * It also normalizes the file path.\n *\n * @return {String}\n */\nSummaryArticle.prototype.getPath = function() {\n    if (this.isExternal()) {\n        return undefined;\n    }\n\n    var ref = this.getRef();\n    if (!ref) {\n        return undefined;\n    }\n\n    var parts = ref.split('#');\n\n    var pathname = (parts.length > 1? parts.slice(0, -1).join('#') : ref);\n\n    // Normalize path to remove ('./', '/...', etc)\n    return location.flatten(pathname);\n};\n\n/**\n * Return url if article is external\n *\n * @return {String}\n */\nSummaryArticle.prototype.getUrl = function() {\n    return this.isExternal()? this.getRef() : undefined;\n};\n\n/**\n * Get anchor for this article (or undefined)\n *\n * @return {String}\n */\nSummaryArticle.prototype.getAnchor = function() {\n    var ref = this.getRef();\n    var parts = ref.split('#');\n\n    var anchor = (parts.length > 1? '#' + parts[parts.length - 1] : undefined);\n    return anchor;\n};\n\n/**\n * Create a new level for a new child article\n *\n * @return {String}\n */\nSummaryArticle.prototype.createChildLevel = function() {\n    var level       = this.getLevel();\n    var subArticles = this.getArticles();\n    var childLevel  = level + '.' + (subArticles.size + 1);\n\n    return childLevel;\n};\n\n/**\n * Is article pointing to a page of an absolute url\n *\n * @return {Boolean}\n */\nSummaryArticle.prototype.isPage = function() {\n    return !this.isExternal() && this.getRef();\n};\n\n/**\n * Check if this article is a file (exatcly)\n *\n * @param {File} file\n * @return {Boolean}\n */\nSummaryArticle.prototype.isFile = function(file) {\n    return (\n        file.getPath() === this.getPath()\n        && this.getAnchor() === undefined\n    );\n};\n\n/**\n * Check if this article is the introduction of the book\n *\n * @param {Book|Readme} book\n * @return {Boolean}\n */\nSummaryArticle.prototype.isReadme = function(book) {\n    var readme = book.getFile? book : book.getReadme();\n    var file = readme.getFile();\n\n    return this.isFile(file);\n};\n\n/**\n * Is article pointing to aan absolute url\n *\n * @return {Boolean}\n */\nSummaryArticle.prototype.isExternal = function() {\n    return location.isExternal(this.getRef());\n};\n\n/**\n * Create a SummaryArticle\n *\n * @param {Object} def\n * @return {SummaryArticle}\n */\nSummaryArticle.create = function(def, level) {\n    var articles = (def.articles || []).map(function(article, i) {\n        if (article instanceof SummaryArticle) {\n            return article;\n        }\n        return SummaryArticle.create(article, [level, i + 1].join('.'));\n    });\n\n    return new SummaryArticle({\n        level: level,\n        title: def.title,\n        ref: def.ref || def.path || '',\n        articles: Immutable.List(articles)\n    });\n};\n\n/**\n * Find an article from a base one\n *\n * @param {Article|Part} base\n * @param {Function(article)} iter\n * @return {Article}\n */\nSummaryArticle.findArticle = function(base, iter) {\n    var articles = base.getArticles();\n\n    return articles.reduce(function(result, article) {\n        if (result) return result;\n\n        if (iter(article)) {\n            return article;\n        }\n\n        return SummaryArticle.findArticle(article, iter);\n    }, null);\n};\n\n\nmodule.exports = SummaryArticle;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/location.js":"var url = require('url');\nvar path = require('path');\n\n// Is the url an external url\nfunction isExternal(href) {\n    try {\n        return Boolean(url.parse(href).protocol) && !isDataURI(href);\n    } catch(err) {\n        return false;\n    }\n}\n\n// Is the url an iniline data-uri\nfunction isDataURI(href) {\n    try {\n        return Boolean(url.parse(href).protocol) && (url.parse(href).protocol === 'data:');\n    } catch(err) {\n        return false;\n    }\n}\n\n// Inverse of isExternal\nfunction isRelative(href) {\n    return !isExternal(href);\n}\n\n// Return true if the link is an achor\nfunction isAnchor(href) {\n    try {\n        var parsed = url.parse(href);\n        return !!(!parsed.protocol && !parsed.path && parsed.hash);\n    } catch(err) {\n        return false;\n    }\n}\n\n// Normalize a path to be a link\nfunction normalize(s) {\n    return path.normalize(s).replace(/\\\\/g, '/');\n}\n\n/**\n * Flatten a path, it removes the leading \"/\"\n *\n * @param {String} href\n * @return {String}\n */\nfunction flatten(href) {\n    href = normalize(href);\n    if (href[0] == '/') {\n        href = normalize(href.slice(1));\n    }\n\n    return href;\n}\n\n/**\n * Convert a relative path to absolute\n *\n * @param {String} href\n * @param {String} dir: directory parent of the file currently in rendering process\n * @param {String} outdir: directory parent from the html output\n * @return {String}\n */\nfunction toAbsolute(_href, dir, outdir) {\n    if (isExternal(_href) || isDataURI(_href)) {\n        return _href;\n    }\n\n    outdir = outdir == undefined? dir : outdir;\n\n    _href = normalize(_href);\n    dir = normalize(dir);\n    outdir = normalize(outdir);\n\n    // Path \"_href\" inside the base folder\n    var hrefInRoot = normalize(path.join(dir, _href));\n    if (_href[0] == '/') {\n        hrefInRoot = normalize(_href.slice(1));\n    }\n\n    // Make it relative to output\n    _href = path.relative(outdir, hrefInRoot);\n\n    // Normalize windows paths\n    _href = normalize(_href);\n\n    return _href;\n}\n\n/**\n * Convert an absolute path to a relative path for a specific folder (dir)\n * ('test/', 'hello.md') -> '../hello.md'\n *\n * @param {String} dir: current directory\n * @param {String} file: absolute path of file\n * @return {String}\n */\nfunction relative(dir, file) {\n    var isDirectory = file.slice(-1) === '/';\n    return normalize(path.relative(dir, file)) + (isDirectory? '/': '');\n}\n\n/**\n * Convert an absolute path to a relative path for a specific folder (dir)\n * ('test/test.md', 'hello.md') -> '../hello.md'\n *\n * @param {String} baseFile: current file\n * @param {String} file: absolute path of file\n * @return {String}\n */\nfunction relativeForFile(baseFile, file) {\n    return relative(path.dirname(baseFile), file);\n}\n\n/**\n * Compare two paths, return true if they are identical\n * ('README.md', './README.md') -> true\n *\n * @param {String} p1: first path\n * @param {String} p2: second path\n * @return {Boolean}\n */\nfunction areIdenticalPaths(p1, p2) {\n    return normalize(p1) === normalize(p2);\n}\n\nmodule.exports = {\n    areIdenticalPaths: areIdenticalPaths,\n    isDataURI:         isDataURI,\n    isExternal:        isExternal,\n    isRelative:        isRelative,\n    isAnchor:          isAnchor,\n    normalize:         normalize,\n    toAbsolute:        toAbsolute,\n    relative:          relative,\n    relativeForFile:   relativeForFile,\n    flatten:           flatten\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/mergeAtLevel.js":"\n/**\n    Edit a list of articles\n\n    @param {List<Article>} articles\n    @param {String} level\n    @param {Article} newArticle\n    @return {List<Article>}\n*/\nfunction editArticleInList(articles, level, newArticle) {\n    return articles.map(function(article) {\n        var articleLevel = article.getLevel();\n\n        if (articleLevel === level) {\n            // it is the article to edit\n            return article.merge(newArticle);\n        } else if (level.indexOf(articleLevel) === 0) {\n            // it is a parent\n            var articles = editArticleInList(article.getArticles(), level, newArticle);\n            return article.set('articles', articles);\n        } else {\n            // This is not the article you are looking for\n            return article;\n        }\n    });\n}\n\n\n/**\n    Edit an article in a part\n\n    @param {Part} part\n    @param {String} level\n    @param {Article} newArticle\n    @return {Part}\n*/\nfunction editArticleInPart(part, level, newArticle) {\n    var articles = part.getArticles();\n    articles = editArticleInList(articles, level, newArticle);\n\n    return part.set('articles', articles);\n}\n\n\n/**\n    Edit an article, or a part, in a summary. Does a shallow merge.\n\n    @param {Summary} summary\n    @param {String} level\n    @param {Article|Part} newValue\n    @return {Summary}\n*/\nfunction mergeAtLevel(summary, level, newValue) {\n    var levelParts = level.split('.');\n    var partIndex = Number(levelParts[0]) -1;\n\n    var parts = summary.getParts();\n    var part = parts.get(partIndex);\n    if (!part) {\n        return summary;\n    }\n\n    var isEditingPart = levelParts.length < 2;\n    if (isEditingPart) {\n        part = part.merge(newValue);\n    } else {\n        part = editArticleInPart(part, level, newValue);\n    }\n\n    parts = parts.set(partIndex, part);\n    return summary.set('parts', parts);\n}\n\n\nmodule.exports = mergeAtLevel;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/indexArticleLevels.js":"\n/**\n    Index levels in an article tree\n\n    @param {Article}\n    @param {String} baseLevel\n    @return {Article}\n*/\nfunction indexArticleLevels(article, baseLevel) {\n    baseLevel = baseLevel || article.getLevel();\n    var articles = article.getArticles();\n\n    articles = articles.map(function(inner, i) {\n        return indexArticleLevels(inner, baseLevel + '.' + (i + 1));\n    });\n\n    return article.merge({\n        level: baseLevel,\n        articles: articles\n    });\n}\n\nmodule.exports = indexArticleLevels;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/moveArticle.js":"var is = require('is');\nvar removeArticle = require('./removeArticle');\nvar insertArticle = require('./insertArticle');\n\n/**\n    Returns a new summary, with the given article removed from its\n    origin level, and placed at the given target level.\n\n    @param {Summary} summary\n    @param {String|SummaryArticle} origin: level to remove\n    @param {String|SummaryArticle} target: the level where the article will be found\n    @return {Summary}\n*/\nfunction moveArticle(summary, origin, target) {\n    // Coerce to level\n    var originLevel = is.string(origin)? origin : origin.getLevel();\n    var targetLevel = is.string(target)? target : target.getLevel();\n    var article = summary.getByLevel(originLevel);\n\n    // Remove first\n    var removed = removeArticle(summary, originLevel);\n    return insertArticle(removed, article, targetLevel);\n}\n\nmodule.exports = moveArticle;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/removeArticle.js":"var is = require('is');\nvar mergeAtLevel = require('./mergeAtLevel');\nvar indexArticleLevels = require('./indexArticleLevels');\n\n/**\n    Remove an article from a level.\n\n    @param {Summary} summary\n    @param {String|SummaryArticle} level: level to remove\n    @return {Summary}\n*/\nfunction removeArticle(summary, level) {\n    // Coerce to level\n    level = is.string(level)? level : level.getLevel();\n\n    var parent = summary.getParent(level);\n\n    var articles = parent.getArticles();\n    // Find the index to remove\n    var index = articles.findIndex(function(art) {\n        return art.getLevel() === level;\n    });\n    if (index === -1) {\n        return summary;\n    }\n\n    // Remove from children\n    articles = articles.remove(index);\n    parent = parent.set('articles', articles);\n\n    // Reindex the level from here\n    parent = indexArticleLevels(parent);\n\n    return mergeAtLevel(summary, parent.getLevel(), parent);\n}\n\nmodule.exports = removeArticle;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/moveArticleAfter.js":"var is = require('is');\nvar removeArticle = require('./removeArticle');\nvar insertArticle = require('./insertArticle');\n\n/**\n    Returns a new summary, with the an article moved after another\n    article. Unlike `moveArticle`, does not ensure that the article\n    will be found at the target's level plus one.\n\n    @param {Summary} summary\n    @param {String|SummaryArticle} origin\n    @param {String|SummaryArticle} afterTarget\n    @return {Summary}\n*/\nfunction moveArticleAfter(summary, origin, afterTarget) {\n    // Coerce to level\n    var originLevel = is.string(origin)? origin : origin.getLevel();\n    var afterTargetLevel = is.string(afterTarget)? afterTarget : afterTarget.getLevel();\n    var article = summary.getByLevel(originLevel);\n\n    var targetLevel = increment(afterTargetLevel);\n\n    if (targetLevel < origin) {\n        // Remove first\n        var removed = removeArticle(summary, originLevel);\n        // Insert then\n        return insertArticle(removed, article, targetLevel);\n    } else {\n        // Insert right after first\n        var inserted = insertArticle(summary, article, targetLevel);\n        // Remove old one\n        return removeArticle(inserted, originLevel);\n    }\n}\n\n/**\n    @param {String}\n    @return {Array<Number>}\n */\nfunction levelToArray(l) {\n    return l.split('.').map(function (char) {\n        return parseInt(char, 10);\n    });\n}\n\n/**\n    @param {Array<Number>}\n    @return {String}\n */\nfunction arrayToLevel(a) {\n    return a.join('.');\n}\n\nfunction increment(level) {\n    level = levelToArray(level);\n    level[level.length - 1]++;\n    return arrayToLevel(level);\n}\n\nmodule.exports = moveArticleAfter;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/unshiftArticle.js":"var SummaryArticle = require('../../models/summaryArticle');\nvar SummaryPart = require('../../models/summaryPart');\n\nvar indexLevels = require('./indexLevels');\n\n/**\n    Insert an article at the beginning of summary\n\n    @param {Summary} summary\n    @param {Article} article\n    @return {Summary}\n*/\nfunction unshiftArticle(summary, article) {\n    article = SummaryArticle(article);\n\n    var parts = summary.getParts();\n    var part = parts.get(0) || SummaryPart();\n\n    var articles = part.getArticles();\n    articles = articles.unshift(article);\n    part = part.set('articles', articles);\n\n    parts = parts.set(0, part);\n    summary = summary.set('parts', parts);\n\n    return indexLevels(summary);\n}\n\nmodule.exports = unshiftArticle;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/summaryPart.js":"var Immutable = require('immutable');\n\nvar SummaryArticle = require('./summaryArticle');\n\n/*\n    A part represents a section in the Summary / table of Contents\n*/\n\nvar SummaryPart = Immutable.Record({\n    level:      String(),\n    title:      String(),\n    articles:   Immutable.List()\n});\n\nSummaryPart.prototype.getLevel = function() {\n    return this.get('level');\n};\n\nSummaryPart.prototype.getTitle = function() {\n    return this.get('title');\n};\n\nSummaryPart.prototype.getArticles = function() {\n    return this.get('articles');\n};\n\n/**\n * Create a new level for a new child article\n *\n * @return {String}\n */\nSummaryPart.prototype.createChildLevel = function() {\n    var level       = this.getLevel();\n    var subArticles = this.getArticles();\n    var childLevel  = level + '.' + (subArticles.size + 1);\n\n    return childLevel;\n};\n\n/**\n * Create a SummaryPart\n *\n * @param {Object} def\n * @return {SummaryPart}\n */\nSummaryPart.create = function(def, level) {\n    var articles = (def.articles || []).map(function(article, i) {\n        if (article instanceof SummaryArticle) {\n            return article;\n        }\n        return SummaryArticle.create(article, [level, i + 1].join('.'));\n    });\n\n    return new SummaryPart({\n        level: String(level),\n        title: def.title,\n        articles: Immutable.List(articles)\n    });\n};\n\nmodule.exports = SummaryPart;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/indexLevels.js":"var indexPartLevels = require('./indexPartLevels');\n\n/**\n    Index all levels in the summary\n\n    @param {Summary}\n    @return {Summary}\n*/\nfunction indexLevels(summary) {\n    var parts = summary.getParts();\n    parts = parts.map(indexPartLevels);\n\n    return summary.set('parts', parts);\n}\n\n\nmodule.exports = indexLevels;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/indexPartLevels.js":"var indexArticleLevels = require('./indexArticleLevels');\n\n/**\n    Index levels in a part\n\n    @param {Part}\n    @param {Number} index\n    @return {Part}\n*/\nfunction indexPartLevels(part, index) {\n    var baseLevel = String(index + 1);\n    var articles = part.getArticles();\n\n    articles = articles.map(function(inner, i) {\n        return indexArticleLevels(inner, baseLevel + '.' + (i + 1));\n    });\n\n    return part.merge({\n        level: baseLevel,\n        articles: articles\n    });\n}\n\nmodule.exports = indexPartLevels;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/editArticleTitle.js":"var mergeAtLevel = require('./mergeAtLevel');\n\n/**\n    Edit title of an article\n\n    @param {Summary} summary\n    @param {String} level\n    @param {String} newTitle\n    @return {Summary}\n*/\nfunction editArticleTitle(summary, level, newTitle) {\n    return mergeAtLevel(summary, level, {\n        title: newTitle\n    });\n}\n\nmodule.exports = editArticleTitle;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/editArticleRef.js":"var mergeAtLevel = require('./mergeAtLevel');\n\n/**\n    Edit the ref of an article\n\n    @param {Summary} summary\n    @param {String} level\n    @param {String} newRef\n    @return {Summary}\n*/\nfunction editArticleRef(summary, level, newRef) {\n    return mergeAtLevel(summary, level, {\n        ref: newRef\n    });\n}\n\nmodule.exports = editArticleRef;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/insertPart.js":"var SummaryPart = require('../../models/summaryPart');\nvar indexLevels = require('./indexLevels');\n\n/**\n    Returns a new Summary with a part inserted at given index\n\n    @param {Summary} summary\n    @param {Part} part\n    @param {Number} index\n    @return {Summary}\n*/\nfunction insertPart(summary, part, index) {\n    part = SummaryPart(part);\n\n    var parts = summary.getParts().insert(index, part);\n    return indexLevels(summary.set('parts', parts));\n}\n\nmodule.exports = insertPart;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/removePart.js":"var indexLevels = require('./indexLevels');\n\n/**\n    Remove a part at given index\n\n    @param {Summary} summary\n    @param {Number|} index\n    @return {Summary}\n*/\nfunction removePart(summary, index) {\n    var parts = summary.getParts().remove(index);\n    return indexLevels(summary.set('parts', parts));\n}\n\nmodule.exports = removePart;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/summary/editPartTitle.js":"/**\n    Edit title of a part in the summary\n\n    @param {Summary} summary\n    @param {Number} index\n    @param {String} newTitle\n    @return {Summary}\n*/\nfunction editPartTitle(summary, index, newTitle) {\n    var parts = summary.getParts();\n\n    var part = parts.get(index);\n    if (!part) {\n        return summary;\n    }\n\n    part = part.set('title', newTitle);\n    parts = parts.set(index, part);\n\n    return summary.set('parts', parts);\n}\n\nmodule.exports = editPartTitle;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/config/index.js":"\nmodule.exports = {\n    addPlugin:       require('./addPlugin'),\n    removePlugin:    require('./removePlugin'),\n    togglePlugin:    require('./togglePlugin'),\n    editPlugin:      require('./editPlugin'),\n    hasPlugin:       require('./hasPlugin'),\n    getPluginConfig: require('./getPluginConfig'),\n    isDefaultPlugin: require('./isDefaultPlugin')\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/config/addPlugin.js":"var PluginDependency = require('../../models/pluginDependency');\nvar togglePlugin = require('./togglePlugin');\nvar isDefaultPlugin = require('./isDefaultPlugin');\n\n/**\n * Add a plugin to a book's configuration\n * @param {Config} config\n * @param {String} pluginName\n * @param {String} version (optional)\n * @return {Config}\n */\nfunction addPlugin(config, pluginName, version) {\n    // For default plugin, we only ensure it is enabled\n    if (isDefaultPlugin(pluginName, version)) {\n        return togglePlugin(config, pluginName, true);\n    }\n\n    var deps = config.getPluginDependencies();\n    var dep = PluginDependency.create(pluginName, version);\n\n    deps = deps.push(dep);\n    return config.setPluginDependencies(deps);\n}\n\nmodule.exports = addPlugin;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/pluginDependency.js":"var is = require('is');\nvar semver = require('semver');\nvar Immutable = require('immutable');\n\nvar PREFIX = require('../constants/pluginPrefix');\nvar DEFAULT_VERSION = '*';\n\n/*\n * PluginDependency represents the informations about a plugin\n * stored in config.plugins\n */\nvar PluginDependency = Immutable.Record({\n    name:       String(),\n\n    // Requirement version (ex: \">1.0.0\")\n    version:    String(DEFAULT_VERSION),\n\n    // Is this plugin enabled or disabled?\n    enabled:    Boolean(true)\n}, 'PluginDependency');\n\nPluginDependency.prototype.getName = function() {\n    return this.get('name');\n};\n\nPluginDependency.prototype.getVersion = function() {\n    return this.get('version');\n};\n\nPluginDependency.prototype.isEnabled = function() {\n    return this.get('enabled');\n};\n\n/**\n * Toggle this plugin state\n * @param  {Boolean}\n * @return {PluginDependency}\n */\nPluginDependency.prototype.toggle = function(state) {\n    if (is.undef(state)) {\n        state = !this.isEnabled();\n    }\n\n    return this.set('enabled', state);\n};\n\n/**\n * Return NPM ID for the dependency\n * @return {String}\n */\nPluginDependency.prototype.getNpmID = function() {\n    return PluginDependency.nameToNpmID(this.getName());\n};\n\n/**\n * Is the plugin using a git dependency\n * @return {Boolean}\n */\nPluginDependency.prototype.isGitDependency = function() {\n    return !semver.validRange(this.getVersion());\n};\n\n/**\n * Create a plugin with a name and a plugin\n * @param {String}\n * @return {Plugin|undefined}\n */\nPluginDependency.create = function(name, version, enabled) {\n    if (is.undefined(enabled)) {\n        enabled = true;\n    }\n\n    return new PluginDependency({\n        name: name,\n        version: version || DEFAULT_VERSION,\n        enabled: Boolean(enabled)\n    });\n};\n\n/**\n * Create a plugin from a string\n * @param {String}\n * @return {Plugin|undefined}\n */\nPluginDependency.createFromString = function(s) {\n    var parts = s.split('@');\n    var name = parts[0];\n    var version = parts.slice(1).join('@');\n    var enabled = true;\n\n    if (name[0] === '-') {\n        enabled = false;\n        name = name.slice(1);\n    }\n\n    return new PluginDependency({\n        name: name,\n        version: version || DEFAULT_VERSION,\n        enabled: enabled\n    });\n};\n\n/**\n * Create a PluginDependency from a string\n * @param {String}\n * @return {List<PluginDependency>}\n */\nPluginDependency.listFromString = function(s) {\n    var parts = s.split(',');\n    return PluginDependency.listFromArray(parts);\n};\n\n/**\n * Create a PluginDependency from an array\n * @param {Array}\n * @return {List<PluginDependency>}\n */\nPluginDependency.listFromArray = function(arr) {\n    return Immutable.List(arr)\n        .map(function(entry) {\n            if (is.string(entry)) {\n                return PluginDependency.createFromString(entry);\n            } else {\n                return PluginDependency({\n                    name: entry.get('name'),\n                    version: entry.get('version')\n                });\n            }\n        })\n        .filter(function(dep) {\n            return Boolean(dep.getName());\n        });\n};\n\n/**\n * Export plugin dependencies as an array\n * @param {List<PluginDependency>} list\n * @return {Array<String>}\n */\nPluginDependency.listToArray = function(list) {\n    return list\n        .map(function(dep) {\n            var result = '';\n\n            if (!dep.isEnabled()) {\n                result += '-';\n            }\n\n            result += dep.getName();\n            if (dep.getVersion() !== DEFAULT_VERSION) {\n                result += '@' + dep.getVersion();\n            }\n\n            return result;\n        })\n        .toJS();\n};\n\n/**\n * Return NPM id for a plugin name\n * @param {String}\n * @return {String}\n */\nPluginDependency.nameToNpmID = function(s) {\n    return PREFIX + s;\n};\n\nmodule.exports = PluginDependency;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/pluginPrefix.js":"\n/*\n    All GitBook plugins are NPM packages starting with this prefix.\n*/\nmodule.exports = 'gitbook-plugin-';\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/config/togglePlugin.js":"var PluginDependency = require('../../models/pluginDependency');\nvar hasPlugin = require('./hasPlugin');\nvar isDefaultPlugin = require('./isDefaultPlugin');\n\n/**\n * Enable/disable a plugin dependency\n * @param {Config} config\n * @param {String} pluginName\n * @param {Boolean} state (optional)\n * @return {Config}\n */\nfunction togglePlugin(config, pluginName, state) {\n    var deps = config.getPluginDependencies();\n\n    // For default plugin, we should ensure it's listed first\n    if (isDefaultPlugin(pluginName) && !hasPlugin(deps, pluginName)) {\n        deps = deps.push(PluginDependency.create(pluginName));\n    }\n\n    deps = deps.map(function(dep) {\n        if (dep.getName() === pluginName) {\n            return dep.toggle(state);\n        }\n\n        return dep;\n    });\n\n    return config.setPluginDependencies(deps);\n}\n\nmodule.exports = togglePlugin;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/config/hasPlugin.js":"\n/**\n * Test if a plugin is listed\n * @param { {List<PluginDependency}} deps\n * @param {String} plugin\n * @param {String} version\n * @return {Boolean}\n */\nfunction hasPlugin(deps, pluginName, version) {\n    return !!deps.find(function(dep) {\n        return dep.getName() === pluginName && (!version || dep.getVersion() === version);\n    });\n}\n\nmodule.exports = hasPlugin;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/config/isDefaultPlugin.js":"var DEFAULT_PLUGINS = require('../../constants/defaultPlugins');\nvar hasPlugin = require('./hasPlugin');\n\n/**\n * Test if a plugin is a default one\n * @param {String} plugin\n * @param {String} version\n * @return {Boolean}\n */\nfunction isDefaultPlugin(pluginName, version) {\n    return hasPlugin(DEFAULT_PLUGINS, pluginName, version);\n}\n\nmodule.exports = isDefaultPlugin;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/defaultPlugins.js":"var Immutable = require('immutable');\nvar PluginDependency = require('../models/pluginDependency');\n\nvar pkg = require('../../package.json');\n\n/**\n * Create a PluginDependency from a dependency of gitbook\n * @param {String} pluginName\n * @return {PluginDependency}\n */\nfunction createFromDependency(pluginName) {\n    var npmID = PluginDependency.nameToNpmID(pluginName);\n    var version = pkg.dependencies[npmID];\n\n    return PluginDependency.create(pluginName, version);\n}\n\n/*\n * List of default plugins for all books,\n * default plugins should be installed in node dependencies of GitBook\n */\nmodule.exports = Immutable.List([\n    'highlight',\n    'search',\n    'lunr',\n    'sharing',\n    'fontsettings',\n    'theme-default'\n]).map(createFromDependency);\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/config/removePlugin.js":"var togglePlugin = require('./togglePlugin');\nvar isDefaultPlugin = require('./isDefaultPlugin');\n\n/**\n * Remove a plugin from a book's configuration\n * @param {Config} config\n * @param {String} plugin\n * @return {Config}\n */\nfunction removePlugin(config, pluginName) {\n    var deps = config.getPluginDependencies();\n\n    // For default plugin, we have to disable it instead of removing from the list\n    if (isDefaultPlugin(pluginName)) {\n        return togglePlugin(config, pluginName, false);\n    }\n\n    // Remove the dependency from the list\n    deps = deps.filterNot(function(dep) {\n        return dep.getName() === pluginName;\n    });\n    return config.setPluginDependencies(deps);\n}\n\nmodule.exports = removePlugin;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/config/editPlugin.js":"\n/**\n * Edit configuration of a plugin\n * @param {Config} config\n * @param {String} plugin\n * @param {Object} pluginConfig\n * @return {Config}\n */\nfunction editPlugin(config, pluginName, pluginConfig) {\n    return config.setValue('pluginsConfig.'+pluginName, pluginConfig);\n}\n\nmodule.exports = editPlugin;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/modifiers/config/getPluginConfig.js":"/**\n * Return the configuration for a plugin\n * @param {Config} config\n * @param {String} pluginName\n * @return {Object}\n */\nfunction getPluginConfig(config, pluginName) {\n    var pluginsConfig = config.getValues().get('pluginsConfig');\n    if (pluginsConfig === undefined) {\n        return {};\n    }\n    var pluginConf = pluginsConfig.get(pluginName);\n    if (pluginConf === undefined) {\n        return {};\n    } else {\n        return pluginConf.toJS();\n    }\n}\n\nmodule.exports = getPluginConfig;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/index.js":"\nmodule.exports = {\n    parseBook:           require('./parseBook'),\n    parseSummary:        require('./parseSummary'),\n    parseGlossary:       require('./parseGlossary'),\n    parseReadme:         require('./parseReadme'),\n    parseConfig:         require('./parseConfig'),\n    parsePagesList:      require('./parsePagesList'),\n    parseIgnore:         require('./parseIgnore'),\n    listAssets:          require('./listAssets'),\n    parseLanguages:      require('./parseLanguages'),\n    parsePage:           require('./parsePage'),\n    parsePageFromString: require('./parsePageFromString'),\n    lookupStructureFile: require('./lookupStructureFile')\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/parseBook.js":"var Promise = require('../utils/promise');\nvar timing = require('../utils/timing');\nvar Book = require('../models/book');\n\nvar parseIgnore = require('./parseIgnore');\nvar parseConfig = require('./parseConfig');\nvar parseGlossary = require('./parseGlossary');\nvar parseSummary = require('./parseSummary');\nvar parseReadme = require('./parseReadme');\nvar parseLanguages = require('./parseLanguages');\n\n/**\n    Parse content of a book\n\n    @param {Book} book\n    @return {Promise<Book>}\n*/\nfunction parseBookContent(book) {\n    return Promise(book)\n        .then(parseReadme)\n        .then(parseSummary)\n        .then(parseGlossary);\n}\n\n/**\n    Parse a multilingual book\n\n    @param {Book} book\n    @return {Promise<Book>}\n*/\nfunction parseMultilingualBook(book) {\n    var languages = book.getLanguages();\n    var langList = languages.getList();\n\n    return Promise.reduce(langList, function(currentBook, lang) {\n        var langID = lang.getID();\n        var child = Book.createFromParent(currentBook, langID);\n        var ignore = currentBook.getIgnore();\n\n        return Promise(child)\n        .then(parseConfig)\n        .then(parseBookContent)\n        .then(function(result) {\n            // Ignore content of this book when generating parent book\n            ignore = ignore.add(langID + '/**');\n            currentBook = currentBook.set('ignore', ignore);\n\n            return currentBook.addLanguageBook(langID, result);\n        });\n    }, book);\n}\n\n\n/**\n    Parse a whole book from a filesystem\n\n    @param {Book} book\n    @return {Promise<Book>}\n*/\nfunction parseBook(book) {\n    return timing.measure(\n        'parse.book',\n        Promise(book)\n        .then(parseIgnore)\n        .then(parseConfig)\n        .then(parseLanguages)\n        .then(function(resultBook) {\n            if (resultBook.isMultilingual()) {\n                return parseMultilingualBook(resultBook);\n            } else {\n                return parseBookContent(resultBook);\n            }\n        })\n    );\n}\n\nmodule.exports = parseBook;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/promise.js":"var Q = require('q');\nvar Immutable = require('immutable');\n\n// Debugging for long stack traces\nif (process.env.DEBUG || process.env.CI) {\n    Q.longStackSupport = true;\n}\n\n/**\n * Reduce an array to a promise\n *\n * @param {Array|List} arr\n * @param {Function(value, element, index)}\n * @return {Promise<Mixed>}\n */\nfunction reduce(arr, iter, base) {\n    arr = Immutable.Iterable.isIterable(arr)? arr : Immutable.List(arr);\n\n    return arr.reduce(function(prev, elem, key) {\n        return prev\n        .then(function(val) {\n            return iter(val, elem, key);\n        });\n    }, Q(base));\n}\n\n/**\n * Iterate over an array using an async iter\n *\n * @param {Array|List} arr\n * @param {Function(value, element, index)}\n * @return {Promise}\n */\nfunction forEach(arr, iter) {\n    return reduce(arr, function(val, el, key) {\n        return iter(el, key);\n    });\n}\n\n/**\n * Transform an array\n *\n * @param {Array|List} arr\n * @param {Function(value, element, index)}\n * @return {Promise}\n */\nfunction serie(arr, iter, base) {\n    return reduce(arr, function(before, item, key) {\n        return Q(iter(item, key))\n        .then(function(r) {\n            before.push(r);\n            return before;\n        });\n    }, []);\n}\n\n/**\n * Iter over an array and return first result (not null)\n *\n * @param {Array|List} arr\n * @param {Function(element, index)}\n * @return {Promise<Mixed>}\n */\nfunction some(arr, iter) {\n    arr = Immutable.List(arr);\n\n    return arr.reduce(function(prev, elem, i) {\n        return prev.then(function(val) {\n            if (val) return val;\n\n            return iter(elem, i);\n        });\n    }, Q());\n}\n\n/**\n * Map an array using an async (promised) iterator\n *\n * @param {Array|List} arr\n * @param {Function(element, index)}\n * @return {Promise<List>}\n */\nfunction mapAsList(arr, iter) {\n    return reduce(arr, function(prev, entry, i) {\n        return Q(iter(entry, i))\n        .then(function(out) {\n            prev.push(out);\n            return prev;\n        });\n    }, []);\n}\n\n/**\n * Map an array or map\n *\n * @param {Array|List|Map|OrderedMap} arr\n * @param {Function(element, key)}\n * @return {Promise<List|Map|OrderedMap>}\n */\nfunction map(arr, iter) {\n    if (Immutable.Map.isMap(arr)) {\n        var type = 'Map';\n        if (Immutable.OrderedMap.isOrderedMap(arr)) {\n            type = 'OrderedMap';\n        }\n\n        return mapAsList(arr, function(value, key) {\n            return Q(iter(value, key))\n            .then(function(result) {\n                return [key, result];\n            });\n        })\n        .then(function(result) {\n            return Immutable[type](result);\n        });\n    } else {\n        return mapAsList(arr, iter)\n        .then(function(result) {\n            return Immutable.List(result);\n        });\n    }\n}\n\n\n/**\n * Wrap a function in a promise\n *\n * @param {Function} func\n * @return {Funciton}\n */\nfunction wrap(func) {\n    return function() {\n        var args = Array.prototype.slice.call(arguments, 0);\n\n        return Q()\n        .then(function() {\n            return func.apply(null, args);\n        });\n    };\n}\n\nmodule.exports = Q;\nmodule.exports.forEach = forEach;\nmodule.exports.reduce = reduce;\nmodule.exports.map = map;\nmodule.exports.serie = serie;\nmodule.exports.some = some;\nmodule.exports.wrapfn = wrap;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/timing.js":"var Immutable = require('immutable');\nvar is = require('is');\n\nvar timers = {};\nvar startDate = Date.now();\n\n/**\n    Mesure an operation\n\n    @parqm {String} type\n    @param {Promise} p\n    @return {Promise}\n*/\nfunction measure(type, p) {\n    timers[type] = timers[type] || {\n        type: type,\n        count: 0,\n        total: 0,\n        min: undefined,\n        max: 0\n    };\n\n    var start = Date.now();\n\n    return p\n    .fin(function() {\n        var end = Date.now();\n        var duration = (end - start);\n\n        timers[type].count ++;\n        timers[type].total += duration;\n\n        if (is.undefined(timers[type].min)) {\n            timers[type].min = duration;\n        } else {\n            timers[type].min = Math.min(timers[type].min, duration);\n        }\n\n        timers[type].max = Math.max(timers[type].max, duration);\n    });\n}\n\n/**\n    Return a milliseconds number as a second string\n\n    @param {Number} ms\n    @return {String}\n*/\nfunction time(ms) {\n    if (ms < 1000) {\n        return (ms.toFixed(0)) + 'ms';\n    }\n\n    return (ms/1000).toFixed(2) + 's';\n}\n\n/**\n    Dump all timers to a logger\n\n    @param {Logger} logger\n*/\nfunction dump(logger) {\n    var prefix = '    > ';\n    var measured = 0;\n    var totalDuration = Date.now() - startDate;\n\n    // Enable debug logging\n    var logLevel = logger.getLevel();\n    logger.setLevel('debug');\n\n    Immutable.Map(timers)\n        .valueSeq()\n        .sortBy(function(timer) {\n            measured += timer.total;\n            return timer.total;\n        })\n        .forEach(function(timer) {\n            var percent = (timer.total * 100) / totalDuration;\n\n\n            logger.debug.ln((percent.toFixed(1)) + '% of time spent in \"' + timer.type + '\" (' + timer.count + ' times) :');\n            logger.debug.ln(prefix + 'Total: ' + time(timer.total)+ ' | Average: ' + time(timer.total / timer.count));\n            logger.debug.ln(prefix + 'Min: ' + time(timer.min) + ' | Max: ' + time(timer.max));\n            logger.debug.ln('---------------------------');\n        });\n\n\n    logger.debug.ln(time(totalDuration - measured) + ' spent in non-mesured sections');\n\n    // Rollback to previous level\n    logger.setLevel(logLevel);\n}\n\nmodule.exports = {\n    measure: measure,\n    dump: dump\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/book.js":"var path = require('path');\nvar Immutable = require('immutable');\n\nvar Logger = require('../utils/logger');\n\nvar FS = require('./fs');\nvar Config = require('./config');\nvar Readme = require('./readme');\nvar Summary = require('./summary');\nvar Glossary = require('./glossary');\nvar Languages = require('./languages');\nvar Ignore = require('./ignore');\n\nvar Book = Immutable.Record({\n    // Logger for outptu message\n    logger:         Logger(),\n\n    // Filesystem binded to the book scope to read files/directories\n    fs:             FS(),\n\n    // Ignore files parser\n    ignore:         Ignore(),\n\n    // Structure files\n    config:         Config(),\n    readme:         Readme(),\n    summary:        Summary(),\n    glossary:       Glossary(),\n    languages:      Languages(),\n\n    // ID of the language for language books\n    language:       String(),\n\n    // List of children, if multilingual (String -> Book)\n    books:          Immutable.OrderedMap()\n});\n\nBook.prototype.getLogger = function() {\n    return this.get('logger');\n};\n\nBook.prototype.getFS = function() {\n    return this.get('fs');\n};\n\nBook.prototype.getIgnore = function() {\n    return this.get('ignore');\n};\n\nBook.prototype.getConfig = function() {\n    return this.get('config');\n};\n\nBook.prototype.getReadme = function() {\n    return this.get('readme');\n};\n\nBook.prototype.getSummary = function() {\n    return this.get('summary');\n};\n\nBook.prototype.getGlossary = function() {\n    return this.get('glossary');\n};\n\nBook.prototype.getLanguages = function() {\n    return this.get('languages');\n};\n\nBook.prototype.getBooks = function() {\n    return this.get('books');\n};\n\nBook.prototype.getLanguage = function() {\n    return this.get('language');\n};\n\n/**\n    Return FS instance to access the content\n\n    @return {FS}\n*/\nBook.prototype.getContentFS = function() {\n    var fs = this.getFS();\n    var config = this.getConfig();\n    var rootFolder = config.getValue('root');\n\n    if (rootFolder) {\n        return FS.reduceScope(fs, rootFolder);\n    }\n\n    return fs;\n};\n\n/**\n    Return root of the book\n\n    @return {String}\n*/\nBook.prototype.getRoot = function() {\n    var fs = this.getFS();\n    return fs.getRoot();\n};\n\n/**\n    Return root for content of the book\n\n    @return {String}\n*/\nBook.prototype.getContentRoot = function() {\n    var fs = this.getContentFS();\n    return fs.getRoot();\n};\n\n/**\n    Check if a file is ignore (should not being parsed, etc)\n\n    @param {String} ref\n    @return {Page|undefined}\n*/\nBook.prototype.isFileIgnored = function(filename) {\n    var ignore = this.getIgnore();\n    var language = this.getLanguage();\n\n    // Ignore is always relative to the root of the main book\n    if (language) {\n        filename = path.join(language, filename);\n    }\n\n    return ignore.isFileIgnored(filename);\n};\n\n/**\n    Check if a content file is ignore (should not being parsed, etc)\n\n    @param {String} ref\n    @return {Page|undefined}\n*/\nBook.prototype.isContentFileIgnored = function(filename) {\n    var config = this.getConfig();\n    var rootFolder = config.getValue('root');\n\n    if (rootFolder) {\n        filename = path.join(rootFolder, filename);\n    }\n\n    return this.isFileIgnored(filename);\n};\n\n/**\n    Return a page from a book by its path\n\n    @param {String} ref\n    @return {Page|undefined}\n*/\nBook.prototype.getPage = function(ref) {\n    return this.getPages().get(ref);\n};\n\n/**\n    Is this book the parent of language's books\n\n    @return {Boolean}\n*/\nBook.prototype.isMultilingual = function() {\n    return (this.getLanguages().getCount() > 0);\n};\n\n/**\n    Return true if book is associated to a language\n\n    @return {Boolean}\n*/\nBook.prototype.isLanguageBook = function() {\n    return Boolean(this.getLanguage());\n};\n\n/**\n    Return a languages book\n\n    @param {String} language\n    @return {Book}\n*/\nBook.prototype.getLanguageBook = function(language) {\n    var books = this.getBooks();\n    return books.get(language);\n};\n\n/**\n    Add a new language book\n\n    @param {String} language\n    @param {Book} book\n    @return {Book}\n*/\nBook.prototype.addLanguageBook = function(language, book) {\n    var books = this.getBooks();\n    books = books.set(language, book);\n\n    return this.set('books', books);\n};\n\n/**\n    Set the summary for this book\n\n    @param {Summary}\n    @return {Book}\n*/\nBook.prototype.setSummary = function(summary) {\n    return this.set('summary', summary);\n};\n\n/**\n    Set the readme for this book\n\n    @param {Readme}\n    @return {Book}\n*/\nBook.prototype.setReadme = function(readme) {\n    return this.set('readme', readme);\n};\n\n/**\n    Set the configuration for this book\n\n    @param {Config}\n    @return {Book}\n*/\nBook.prototype.setConfig = function(config) {\n    return this.set('config', config);\n};\n\n/**\n    Set the ignore instance for this book\n\n    @param {Ignore}\n    @return {Book}\n*/\nBook.prototype.setIgnore = function(ignore) {\n    return this.set('ignore', ignore);\n};\n\n/**\n    Change log level\n\n    @param {String} level\n    @return {Book}\n*/\nBook.prototype.setLogLevel = function(level) {\n    this.getLogger().setLevel(level);\n    return this;\n};\n\n/**\n    Create a book using a filesystem\n\n    @param {FS} fs\n    @return {Book}\n*/\nBook.createForFS = function createForFS(fs) {\n    return new Book({\n        fs: fs\n    });\n};\n\n/**\n    Infers the default extension for files\n    @return {String}\n*/\nBook.prototype.getDefaultExt = function() {\n    // Inferring sources\n    var clues = [\n        this.getReadme(),\n        this.getSummary(),\n        this.getGlossary()\n    ];\n\n    // List their extensions\n    var exts = clues.map(function (clue) {\n        var file = clue.getFile();\n        if (file.exists()) {\n            return file.getParser().getExtensions().first();\n        } else {\n            return null;\n        }\n    });\n    // Adds the general default extension\n    exts.push('.md');\n\n    // Choose the first non null\n    return exts.find(function (e) { return e !== null; });\n};\n\n/**\n    Infer the default path for a Readme.\n    @param {Boolean} [absolute=false] False for a path relative to\n        this book's content root\n    @return {String}\n*/\nBook.prototype.getDefaultReadmePath = function(absolute) {\n    var defaultPath = 'README'+this.getDefaultExt();\n    if (absolute) {\n        return path.join(this.getContentRoot(), defaultPath);\n    } else {\n        return defaultPath;\n    }\n};\n\n/**\n    Infer the default path for a Summary.\n    @param {Boolean} [absolute=false] False for a path relative to\n        this book's content root\n    @return {String}\n*/\nBook.prototype.getDefaultSummaryPath = function(absolute) {\n    var defaultPath = 'SUMMARY'+this.getDefaultExt();\n    if (absolute) {\n        return path.join(this.getContentRoot(), defaultPath);\n    } else {\n        return defaultPath;\n    }\n};\n\n/**\n    Infer the default path for a Glossary.\n    @param {Boolean} [absolute=false] False for a path relative to\n        this book's content root\n    @return {String}\n*/\nBook.prototype.getDefaultGlossaryPath = function(absolute) {\n    var defaultPath = 'GLOSSARY'+this.getDefaultExt();\n    if (absolute) {\n        return path.join(this.getContentRoot(), defaultPath);\n    } else {\n        return defaultPath;\n    }\n};\n\n/**\n    Create a language book from a parent\n\n    @param {Book} parent\n    @param {String} language\n    @return {Book}\n*/\nBook.createFromParent = function createFromParent(parent, language) {\n    var ignore = parent.getIgnore();\n    var config = parent.getConfig();\n\n    // Set language in configuration\n    config = config.setValue('language', language);\n\n    return new Book({\n        // Inherits config. logegr and list of ignored files\n        logger: parent.getLogger(),\n        config: config,\n        ignore: ignore,\n\n        language: language,\n        fs: FS.reduceScope(parent.getContentFS(), language)\n    });\n};\n\nmodule.exports = Book;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/logger.js":"var is = require('is');\nvar util = require('util');\nvar color = require('bash-color');\nvar Immutable = require('immutable');\n\nvar LEVELS = Immutable.Map({\n    DEBUG: 0,\n    INFO: 1,\n    WARN: 2,\n    ERROR: 3,\n    DISABLED: 10\n});\n\nvar COLORS = Immutable.Map({\n    DEBUG: color.purple,\n    INFO: color.cyan,\n    WARN: color.yellow,\n    ERROR: color.red\n});\n\nfunction Logger(write, logLevel) {\n    if (!(this instanceof Logger)) return new Logger(write, logLevel);\n\n    this._write = write || function(msg) {\n        if(process.stdout) {\n            process.stdout.write(msg);\n        }\n    };\n    this.lastChar = '\\n';\n\n    this.setLevel(logLevel || 'info');\n\n    // Create easy-to-use method like \"logger.debug.ln('....')\"\n    LEVELS.forEach(function(level, levelKey) {\n        if (levelKey === 'DISABLED') {\n            return;\n        }\n        levelKey = levelKey.toLowerCase();\n\n        this[levelKey] =            this.log.bind(this, level);\n        this[levelKey].ln =         this.logLn.bind(this, level);\n        this[levelKey].ok =         this.ok.bind(this, level);\n        this[levelKey].fail =       this.fail.bind(this, level);\n        this[levelKey].promise =    this.promise.bind(this, level);\n    }, this);\n}\n\n/**\n    Change minimum level\n\n    @param {String} logLevel\n*/\nLogger.prototype.setLevel = function(logLevel) {\n    if (is.string(logLevel)) {\n        logLevel = logLevel.toUpperCase();\n        logLevel = LEVELS.get(logLevel);\n    }\n\n    this.logLevel = logLevel;\n};\n\n/**\n    Return minimum logging level\n\n    @return {Number}\n*/\nLogger.prototype.getLevel = function(logLevel) {\n    return this.logLevel;\n};\n\n/**\n    Print a simple string\n\n    @param {String}\n*/\nLogger.prototype.write = function(msg) {\n    msg = msg.toString();\n    this.lastChar = msg[msg.length - 1];\n    return this._write(msg);\n};\n\n/**\n    Format a string using the first argument as a printf-like format.\n*/\nLogger.prototype.format = function() {\n    return util.format.apply(util, arguments);\n};\n\n/**\n    Print a line\n\n    @param {String}\n*/\nLogger.prototype.writeLn = function(msg) {\n    return this.write((msg || '')+'\\n');\n};\n\n/**\n    Log/Print a message if level is allowed\n\n    @param {Number} level\n*/\nLogger.prototype.log = function(level) {\n    if (level < this.logLevel) return;\n\n    var levelKey = LEVELS.findKey(function(v) {\n        return v === level;\n    });\n    var args = Array.prototype.slice.apply(arguments, [1]);\n    var msg = this.format.apply(this, args);\n\n    if (this.lastChar == '\\n') {\n        msg = COLORS.get(levelKey)(levelKey.toLowerCase()+':')+' '+msg;\n    }\n\n    return this.write(msg);\n};\n\n/**\n    Log/Print a line if level is allowed\n*/\nLogger.prototype.logLn = function() {\n    if (this.lastChar != '\\n') this.write('\\n');\n\n    var args = Array.prototype.slice.apply(arguments);\n    args.push('\\n');\n    return this.log.apply(this, args);\n};\n\n/**\n    Log a confirmation [OK]\n*/\nLogger.prototype.ok = function(level) {\n    var args = Array.prototype.slice.apply(arguments, [1]);\n    var msg = this.format.apply(this, args);\n    if (arguments.length > 1) {\n        this.logLn(level, color.green('>> ') + msg.trim().replace(/\\n/g, color.green('\\n>> ')));\n    } else {\n        this.log(level, color.green('OK'), '\\n');\n    }\n};\n\n/**\n    Log a \"FAIL\"\n*/\nLogger.prototype.fail = function(level) {\n    return this.log(level, color.red('ERROR') + '\\n');\n};\n\n/**\n    Log state of a promise\n\n    @param {Number} level\n    @param {Promise}\n    @return {Promise}\n*/\nLogger.prototype.promise = function(level, p) {\n    var that = this;\n\n    return p.\n    then(function(st) {\n        that.ok(level);\n        return st;\n    }, function(err) {\n        that.fail(level);\n        throw err;\n    });\n};\n\nLogger.LEVELS = LEVELS;\n\nmodule.exports =  Logger;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/fs.js":"var path = require('path');\nvar Immutable = require('immutable');\nvar stream = require('stream');\n\nvar File = require('./file');\nvar Promise = require('../utils/promise');\nvar error = require('../utils/error');\nvar PathUtil = require('../utils/path');\n\nvar FS = Immutable.Record({\n    root:           String(),\n\n    fsExists:         Function(),\n    fsReadFile:       Function(),\n    fsStatFile:       Function(),\n    fsReadDir:        Function(),\n\n    fsLoadObject:     null,\n    fsReadAsStream:   null\n});\n\n/**\n    Return path to the root\n\n    @return {String}\n*/\nFS.prototype.getRoot = function() {\n    return this.get('root');\n};\n\n/**\n    Verify that a file is in the fs scope\n\n    @param {String} filename\n    @return {Boolean}\n*/\nFS.prototype.isInScope = function(filename) {\n    var rootPath = this.getRoot();\n    filename = path.join(rootPath, filename);\n\n    return PathUtil.isInRoot(rootPath, filename);\n};\n\n/**\n    Resolve a file in this FS\n\n    @param {String}\n    @return {String}\n*/\nFS.prototype.resolve = function() {\n    var rootPath = this.getRoot();\n    var args = Array.prototype.slice.call(arguments);\n    var filename = path.join.apply(path, [rootPath].concat(args));\n    filename = path.normalize(filename);\n\n    if (!this.isInScope(filename)) {\n        throw error.FileOutOfScopeError({\n            filename: filename,\n            root: this.root\n        });\n    }\n\n    return filename;\n};\n\n/**\n    Check if a file exists, run a Promise(true) if that's the case, Promise(false) otherwise\n\n    @param {String} filename\n    @return {Promise<Boolean>}\n*/\nFS.prototype.exists = function(filename) {\n    var that = this;\n\n    return Promise()\n    .then(function() {\n        filename = that.resolve(filename);\n        var exists = that.get('fsExists');\n\n        return exists(filename);\n    });\n};\n\n/**\n    Read a file and returns a promise with the content as a buffer\n\n    @param {String} filename\n    @return {Promise<Buffer>}\n*/\nFS.prototype.read = function(filename) {\n    var that = this;\n\n    return Promise()\n    .then(function() {\n        filename = that.resolve(filename);\n        var read = that.get('fsReadFile');\n\n        return read(filename);\n    });\n};\n\n/**\n    Read a file as a string (utf-8)\n\n    @param {String} filename\n    @return {Promise<String>}\n*/\nFS.prototype.readAsString = function(filename, encoding) {\n    encoding = encoding || 'utf8';\n\n    return this.read(filename)\n    .then(function(buf) {\n        return buf.toString(encoding);\n    });\n};\n\n/**\n    Read file as a stream\n\n    @param {String} filename\n    @return {Promise<Stream>}\n*/\nFS.prototype.readAsStream = function(filename) {\n    var that = this;\n    var filepath = that.resolve(filename);\n    var fsReadAsStream = this.get('fsReadAsStream');\n\n    if (fsReadAsStream) {\n        return Promise(fsReadAsStream(filepath));\n    }\n\n    return this.read(filename)\n    .then(function(buf) {\n        var bufferStream = new stream.PassThrough();\n        bufferStream.end(buf);\n\n        return bufferStream;\n    });\n};\n\n/**\n    Read stat infos about a file\n\n    @param {String} filename\n    @return {Promise<File>}\n*/\nFS.prototype.statFile = function(filename) {\n    var that = this;\n\n    return Promise()\n    .then(function() {\n        var filepath = that.resolve(filename);\n        var stat = that.get('fsStatFile');\n\n        return stat(filepath);\n    })\n    .then(function(stat) {\n        return File.createFromStat(filename, stat);\n    });\n};\n\n/**\n    List files/directories in a directory.\n    Directories ends with '/'\n\n    @param {String} dirname\n    @return {Promise<List<String>>}\n*/\nFS.prototype.readDir = function(dirname) {\n    var that = this;\n\n    return Promise()\n    .then(function() {\n        var dirpath = that.resolve(dirname);\n        var readDir = that.get('fsReadDir');\n\n        return readDir(dirpath);\n    })\n    .then(function(files) {\n        return Immutable.List(files);\n    });\n};\n\n/**\n    List only files in a diretcory\n    Directories ends with '/'\n\n    @param {String} dirname\n    @return {Promise<List<String>>}\n*/\nFS.prototype.listFiles = function(dirname) {\n    return this.readDir(dirname)\n    .then(function(files) {\n        return files.filterNot(pathIsFolder);\n    });\n};\n\n/**\n    List all files in a directory\n\n    @param {String} dirName\n    @param {Function(dirName)} filterFn: call it for each file/directory to test if it should stop iterating\n    @return {Promise<List<String>>}\n*/\nFS.prototype.listAllFiles = function(dirName, filterFn) {\n    var that = this;\n    dirName = dirName || '.';\n\n    return this.readDir(dirName)\n    .then(function(files) {\n        return Promise.reduce(files, function(out, file) {\n            var isDirectory = pathIsFolder(file);\n            var newDirName = path.join(dirName, file);\n\n            if (filterFn && filterFn(newDirName) === false) {\n                return out;\n            }\n\n            if (!isDirectory) {\n                return out.push(newDirName);\n            }\n\n            return that.listAllFiles(newDirName, filterFn)\n            .then(function(inner) {\n                return out.concat(inner);\n            });\n        }, Immutable.List());\n    });\n};\n\n/**\n    Find a file in a folder (case insensitive)\n    Return the found filename\n\n    @param {String} dirname\n    @param {String} filename\n    @return {Promise<String>}\n*/\nFS.prototype.findFile = function(dirname, filename) {\n    return this.listFiles(dirname)\n    .then(function(files) {\n        return files.find(function(file) {\n            return (file.toLowerCase() == filename.toLowerCase());\n        });\n    });\n};\n\n/**\n    Load a JSON file\n    By default, fs only supports JSON\n\n    @param {String} filename\n    @return {Promise<Object>}\n*/\nFS.prototype.loadAsObject = function(filename) {\n    var that = this;\n    var fsLoadObject = this.get('fsLoadObject');\n\n    return this.exists(filename)\n    .then(function(exists) {\n        if (!exists) {\n            var err = new Error('Module doesn\\'t exist');\n            err.code = 'MODULE_NOT_FOUND';\n\n            throw err;\n        }\n\n        if (fsLoadObject) {\n            return fsLoadObject(that.resolve(filename));\n        } else {\n            return that.readAsString(filename)\n            .then(function(str) {\n                return JSON.parse(str);\n            });\n        }\n    });\n};\n\n/**\n    Create a FS instance\n\n    @param {Object} def\n    @return {FS}\n*/\nFS.create = function create(def) {\n    return new FS(def);\n};\n\n/**\n    Create a new FS instance with a reduced scope\n\n    @param {FS} fs\n    @param {String} scope\n    @return {FS}\n*/\nFS.reduceScope = function reduceScope(fs, scope) {\n    return fs.set('root', path.join(fs.getRoot(), scope));\n};\n\n\n// .readdir return files/folder as a list of string, folder ending with '/'\nfunction pathIsFolder(filename) {\n    var lastChar = filename[filename.length - 1];\n    return lastChar == '/' || lastChar == '\\\\';\n}\n\nmodule.exports = FS;","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/file.js":"var path = require('path');\nvar Immutable = require('immutable');\n\nvar parsers = require('../parsers');\n\nvar File = Immutable.Record({\n    // Path of the file, relative to the FS\n    path:       String(),\n\n    // Time when file data last modified\n    mtime:      Date()\n});\n\nFile.prototype.getPath = function() {\n    return this.get('path');\n};\n\nFile.prototype.getMTime = function() {\n    return this.get('mtime');\n};\n\n/**\n    Does the file exists / is set\n\n    @return {Boolean}\n*/\nFile.prototype.exists = function() {\n    return Boolean(this.getPath());\n};\n\n/**\n    Return type of file ('markdown' or 'asciidoc')\n\n    @return {String}\n*/\nFile.prototype.getType = function() {\n    var parser = this.getParser();\n    if (parser) {\n        return parser.getName();\n    } else {\n        return undefined;\n    }\n};\n\n/**\n    Return extension of this file (lowercased)\n\n    @return {String}\n*/\nFile.prototype.getExtension = function() {\n    return path.extname(this.getPath()).toLowerCase();\n};\n\n/**\n    Return parser for this file\n\n    @return {Parser}\n*/\nFile.prototype.getParser = function() {\n    return parsers.getByExt(this.getExtension());\n};\n\n/**\n    Create a file from stats informations\n\n    @param {String} filepath\n    @param {Object|fs.Stats} stat\n    @return {File}\n*/\nFile.createFromStat = function createFromStat(filepath, stat) {\n    return new File({\n        path: filepath,\n        mtime: stat.mtime\n    });\n};\n\n/**\n    Create a file with only a path\n\n    @param {String} filepath\n    @return {File}\n*/\nFile.createWithFilepath = function createWithFilepath(filepath) {\n    return new File({\n        path: filepath\n    });\n};\n\nmodule.exports = File;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parsers.js":"var path = require('path');\nvar Immutable = require('immutable');\n\nvar markdownParser = require('gitbook-markdown');\nvar asciidocParser = require('gitbook-asciidoc');\n\nvar EXTENSIONS_MARKDOWN = require('./constants/extsMarkdown');\nvar EXTENSIONS_ASCIIDOC = require('./constants/extsAsciidoc');\nvar Parser = require('./models/parser');\n\n// This list is ordered by priority of parsers to use\nvar parsers = Immutable.List([\n    Parser.create('markdown', EXTENSIONS_MARKDOWN, markdownParser),\n    Parser.create('asciidoc', EXTENSIONS_ASCIIDOC, asciidocParser)\n]);\n\n/**\n * Return a specific parser by its name\n *\n * @param {String} name\n * @return {Parser|undefined}\n */\nfunction getParser(name) {\n    return parsers.find(function(parser) {\n        return parser.getName() === name;\n    });\n}\n\n/**\n * Return a specific parser according to an extension\n *\n * @param {String} ext\n * @return {Parser|undefined}\n */\nfunction getParserByExt(ext) {\n    return parsers.find(function(parser) {\n        return parser.matchExtension(ext);\n    });\n}\n\n/**\n * Return parser for a file\n *\n * @param {String} ext\n * @return {Parser|undefined}\n */\nfunction getParserForFile(filename) {\n    return getParserByExt(path.extname(filename));\n}\n\n// List all parsable extensions\nvar extensions = parsers\n    .map(function(parser) {\n        return parser.getExtensions();\n    })\n    .flatten();\n\nmodule.exports = {\n    extensions: extensions,\n    get: getParser,\n    getByExt: getParserByExt,\n    getForFile: getParserForFile\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/extsMarkdown.js":"module.exports = [\n    '.md',\n    '.markdown',\n    '.mdown'\n];\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/extsAsciidoc.js":"module.exports = [\n    '.adoc',\n    '.asciidoc'\n];\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/parser.js":"var Immutable = require('immutable');\nvar Promise = require('../utils/promise');\n\nvar Parser = Immutable.Record({\n    name:           String(),\n\n    // List of extensions that can be processed using this parser\n    extensions:     Immutable.List(),\n\n    // Parsing functions\n    readme:         Function(),\n    langs:          Function(),\n    summary:        Function(),\n    glossary:       Function(),\n    page:           Function(),\n    inline:         Function()\n});\n\nParser.prototype.getName = function() {\n    return this.get('name');\n};\n\nParser.prototype.getExtensions = function() {\n    return this.get('extensions');\n};\n\n// PARSE\n\nParser.prototype.parseReadme = function(content) {\n    var readme = this.get('readme');\n    return Promise(readme(content));\n};\n\nParser.prototype.parseSummary = function(content) {\n    var summary = this.get('summary');\n    return Promise(summary(content));\n};\n\nParser.prototype.parseGlossary = function(content) {\n    var glossary = this.get('glossary');\n    return Promise(glossary(content));\n};\n\nParser.prototype.preparePage = function(content) {\n    var page = this.get('page');\n    if (!page.prepare) {\n        return Promise(content);\n    }\n\n    return Promise(page.prepare(content));\n};\n\nParser.prototype.parsePage = function(content) {\n    var page = this.get('page');\n    return Promise(page(content));\n};\n\nParser.prototype.parseInline = function(content) {\n    var inline = this.get('inline');\n    return Promise(inline(content));\n};\n\nParser.prototype.parseLanguages = function(content) {\n    var langs = this.get('langs');\n    return Promise(langs(content));\n};\n\nParser.prototype.parseInline = function(content) {\n    var inline = this.get('inline');\n    return Promise(inline(content));\n};\n\n// TO TEXT\n\nParser.prototype.renderLanguages = function(content) {\n    var langs = this.get('langs');\n    return Promise(langs.toText(content));\n};\n\nParser.prototype.renderSummary = function(content) {\n    var summary = this.get('summary');\n    return Promise(summary.toText(content));\n};\n\nParser.prototype.renderGlossary = function(content) {\n    var glossary = this.get('glossary');\n    return Promise(glossary.toText(content));\n};\n\n/**\n    Test if this parser matches an extension\n\n    @param {String} ext\n    @return {Boolean}\n*/\nParser.prototype.matchExtension = function(ext) {\n    var exts = this.getExtensions();\n    return exts.includes(ext.toLowerCase());\n};\n\n/**\n    Create a new parser using a module (gitbook-markdown, etc)\n\n    @param {String} name\n    @param {Array<String>} extensions\n    @param {Object} module\n    @return {Parser}\n*/\nParser.create = function(name, extensions, module) {\n    return new Parser({\n        name: name,\n        extensions: Immutable.List(extensions),\n        readme:         module.readme,\n        langs:          module.langs,\n        summary:        module.summary,\n        glossary:       module.glossary,\n        page:           module.page,\n        inline:         module.inline\n    });\n};\n\nmodule.exports = Parser;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/error.js":"var is = require('is');\n\nvar TypedError = require('error/typed');\nvar WrappedError = require('error/wrapped');\n\n\n// Enforce as an Error object, and cleanup message\nfunction enforce(err) {\n    if (is.string(err)) err = new Error(err);\n    err.message = err.message.replace(/^Error: /, '');\n\n    return err;\n}\n\n// Random error wrappers during parsing/generation\nvar ParsingError = WrappedError({\n    message: 'Parsing Error: {origMessage}',\n    type: 'parse'\n});\nvar OutputError = WrappedError({\n    message: 'Output Error: {origMessage}',\n    type: 'generate'\n});\n\n// A file does not exists\nvar FileNotFoundError = TypedError({\n    type: 'file.not-found',\n    message: 'No \"{filename}\" file (or is ignored)',\n    filename: null\n});\n\n// A file cannot be parsed\nvar FileNotParsableError = TypedError({\n    type: 'file.not-parsable',\n    message: '\"{filename}\" file cannot be parsed',\n    filename: null\n});\n\n// A file is outside the scope\nvar FileOutOfScopeError = TypedError({\n    type: 'file.out-of-scope',\n    message: '\"{filename}\" not in \"{root}\"',\n    filename: null,\n    root: null,\n    code: 'EACCESS'\n});\n\n// A file is outside the scope\nvar RequireInstallError = TypedError({\n    type: 'install.required',\n    message: '\"{cmd}\" is not installed.\\n{install}',\n    cmd: null,\n    code: 'ENOENT',\n    install: ''\n});\n\n// Error for nunjucks templates\nvar TemplateError = WrappedError({\n    message: 'Error compiling template \"{filename}\": {origMessage}',\n    type: 'template',\n    filename: null\n});\n\n// Error for nunjucks templates\nvar PluginError = WrappedError({\n    message: 'Error with plugin \"{plugin}\": {origMessage}',\n    type: 'plugin',\n    plugin: null\n});\n\n// Error with the book's configuration\nvar ConfigurationError = WrappedError({\n    message: 'Error with book\\'s configuration: {origMessage}',\n    type: 'configuration'\n});\n\n// Error during ebook generation\nvar EbookError = WrappedError({\n    message: 'Error during ebook generation: {origMessage}\\n{stdout}',\n    type: 'ebook',\n    stdout: ''\n});\n\nmodule.exports = {\n    enforce: enforce,\n\n    ParsingError: ParsingError,\n    OutputError: OutputError,\n    RequireInstallError: RequireInstallError,\n\n    FileNotParsableError: FileNotParsableError,\n    FileNotFoundError: FileNotFoundError,\n    FileOutOfScopeError: FileOutOfScopeError,\n\n    TemplateError: TemplateError,\n    PluginError: PluginError,\n    ConfigurationError: ConfigurationError,\n    EbookError: EbookError\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/path.js":"var path = require('path');\nvar error = require('./error');\n\n// Normalize a filename\nfunction normalizePath(filename) {\n    return path.normalize(filename);\n}\n\n// Return true if file path is inside a folder\nfunction isInRoot(root, filename) {\n    root = path.normalize(root);\n    filename = path.normalize(filename);\n\n    if (root === '.') {\n        return true;\n    }\n    if (root[root.length - 1] != path.sep) {\n        root = root + path.sep;\n    }\n\n    return (filename.substr(0, root.length) === root);\n}\n\n// Resolve paths in a specific folder\n// Throw error if file is outside this folder\nfunction resolveInRoot(root) {\n    var input, result;\n    var args = Array.prototype.slice.call(arguments, 1);\n\n    input = args\n        .reduce(function(current, p) {\n            // Handle path relative to book root (\"/README.md\")\n            if (p[0] == '/' || p[0] == '\\\\') return p.slice(1);\n\n            return current? path.join(current, p) : path.normalize(p);\n        }, '');\n\n    result = path.resolve(root, input);\n\n    if (!isInRoot(root, result)) {\n        throw new error.FileOutOfScopeError({\n            filename: result,\n            root: root\n        });\n    }\n\n    return result;\n}\n\n// Chnage extension of a file\nfunction setExtension(filename, ext) {\n    return path.join(\n        path.dirname(filename),\n        path.basename(filename, path.extname(filename)) + ext\n    );\n}\n\n/*\n    Return true if a filename is relative.\n\n    @param {String}\n    @return {Boolean}\n*/\nfunction isPureRelative(filename) {\n    return (filename.indexOf('./') === 0 || filename.indexOf('../') === 0);\n}\n\nmodule.exports = {\n    isInRoot: isInRoot,\n    resolveInRoot: resolveInRoot,\n    normalize: normalizePath,\n    setExtension: setExtension,\n    isPureRelative: isPureRelative\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/config.js":"var is = require('is');\nvar Immutable = require('immutable');\n\nvar File = require('./file');\nvar PluginDependency = require('./pluginDependency');\nvar configDefault = require('../constants/configDefault');\nvar reducedObject = require('../utils/reducedObject');\n\nvar Config = Immutable.Record({\n    file:       File(),\n    values:     configDefault\n}, 'Config');\n\nConfig.prototype.getFile = function() {\n    return this.get('file');\n};\n\nConfig.prototype.getValues = function() {\n    return this.get('values');\n};\n\n/**\n * Return minimum version of configuration,\n * Basically it returns the current config minus the default one\n * @return {Map}\n */\nConfig.prototype.toReducedVersion = function() {\n    return reducedObject(configDefault, this.getValues());\n};\n\n/**\n * Render config as text\n * @return {Promise<String>}\n */\nConfig.prototype.toText = function() {\n    return JSON.stringify(this.toReducedVersion().toJS(), null, 4);\n};\n\n/**\n * Change the file for the configuration\n * @param {File} file\n * @return {Config}\n */\nConfig.prototype.setFile = function(file) {\n    return this.set('file', file);\n};\n\n/**\n * Return a configuration value by its key path\n * @param {String} key\n * @return {Mixed}\n */\nConfig.prototype.getValue = function(keyPath, def) {\n    var values = this.getValues();\n    keyPath = Config.keyToKeyPath(keyPath);\n\n    if (!values.hasIn(keyPath)) {\n        return Immutable.fromJS(def);\n    }\n\n    return values.getIn(keyPath);\n};\n\n/**\n * Update a configuration value\n * @param {String} key\n * @param {Mixed} value\n * @return {Config}\n */\nConfig.prototype.setValue = function(keyPath, value) {\n    keyPath = Config.keyToKeyPath(keyPath);\n\n    value = Immutable.fromJS(value);\n\n    var values = this.getValues();\n    values = values.setIn(keyPath, value);\n\n    return this.set('values', values);\n};\n\n/**\n * Return a list of plugin dependencies\n * @return {List<PluginDependency>}\n */\nConfig.prototype.getPluginDependencies = function() {\n    var plugins = this.getValue('plugins');\n\n    if (is.string(plugins)) {\n        return PluginDependency.listFromString(plugins);\n    } else {\n        return PluginDependency.listFromArray(plugins);\n    }\n};\n\n/**\n * Return a plugin dependency by its name\n * @param {String} name\n * @return {PluginDependency}\n */\nConfig.prototype.getPluginDependency = function(name) {\n    var plugins = this.getPluginDependencies();\n\n    return plugins.find(function(dep) {\n        return dep.getName() === name;\n    });\n};\n\n/**\n * Update the list of plugins dependencies\n * @param {List<PluginDependency>}\n * @return {Config}\n */\nConfig.prototype.setPluginDependencies = function(deps) {\n    var plugins = PluginDependency.listToArray(deps);\n\n    return this.setValue('plugins', plugins);\n};\n\n\n/**\n * Update values for an existing configuration\n * @param {Object} values\n * @returns {Config}\n */\nConfig.prototype.updateValues = function(values) {\n    values = Immutable.fromJS(values);\n\n    return this.set('values', values);\n};\n\n/**\n * Update values for an existing configuration\n * @param {Config} config\n * @param {Object} values\n * @returns {Config}\n */\nConfig.prototype.mergeValues = function(values) {\n    var currentValues = this.getValues();\n    values = Immutable.fromJS(values);\n\n    currentValues = currentValues.mergeDeep(values);\n\n    return this.set('values', currentValues);\n};\n\n/**\n * Create a new config for a file\n * @param {File} file\n * @param {Object} values\n * @returns {Config}\n */\nConfig.create = function(file, values) {\n    return new Config({\n        file: file,\n        values: Immutable.fromJS(values)\n    });\n};\n\n/**\n * Create a new config\n * @param {Object} values\n * @returns {Config}\n */\nConfig.createWithValues = function(values) {\n    return new Config({\n        values: Immutable.fromJS(values)\n    });\n};\n\n\n/**\n * Convert a keyPath to an array of keys\n * @param {String|Array}\n * @return {Array}\n */\nConfig.keyToKeyPath = function(keyPath) {\n    if (is.string(keyPath)) keyPath = keyPath.split('.');\n    return keyPath;\n};\n\nmodule.exports = Config;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/configDefault.js":"var Immutable = require('immutable');\nvar jsonSchemaDefaults = require('json-schema-defaults');\n\nvar schema = require('./configSchema');\n\nmodule.exports = Immutable.fromJS(jsonSchemaDefaults(schema));\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/configSchema.js":"var FILENAME_REGEX = '^[a-zA-Z-._\\d,\\s]+$';\n\nmodule.exports = {\n    '$schema': 'http://json-schema.org/schema#',\n    'id': 'https://gitbook.com/schemas/book.json',\n    'title': 'GitBook Configuration',\n    'type': 'object',\n    'properties': {\n        'root': {\n            'type': 'string',\n            'title': 'Path fro the root folder containing the book\\'s content'\n        },\n        'title': {\n            'type': 'string',\n            'title': 'Title of the book, default is extracted from README'\n        },\n        'isbn': {\n            'type': 'string',\n            'title': 'ISBN for published book'\n        },\n        'language': {\n            'type': 'string',\n            'title': 'Language of the book'\n        },\n        'author': {\n            'type': 'string',\n            'title': 'Name of the author'\n        },\n        'gitbook': {\n            'type': 'string',\n            'default': '*',\n            'title': 'GitBook version to match'\n        },\n        'direction': {\n            'type': 'string',\n            'enum': ['ltr', 'rtl'],\n            'title': 'Direction of texts, default is detected in the pages'\n        },\n        'theme': {\n            'type': 'string',\n            'default': 'default',\n            'title': 'Name of the theme plugin to use'\n        },\n        'variables': {\n            'type': 'object',\n            'title': 'Templating context variables'\n        },\n        'plugins': {\n            'oneOf': [\n                { '$ref': '#/definitions/pluginsArray' },\n                { '$ref': '#/definitions/pluginsString' }\n            ],\n            'default': []\n        },\n        'pluginsConfig': {\n            'type': 'object',\n            'title': 'Configuration for plugins'\n        },\n        'structure': {\n            'type': 'object',\n            'properties': {\n                'langs': {\n                    'default': 'LANGS.md',\n                    'type': 'string',\n                    'title': 'File to use as languages index',\n                    'pattern': FILENAME_REGEX\n                },\n                'readme': {\n                    'default': 'README.md',\n                    'type': 'string',\n                    'title': 'File to use as preface',\n                    'pattern': FILENAME_REGEX\n                },\n                'glossary': {\n                    'default': 'GLOSSARY.md',\n                    'type': 'string',\n                    'title': 'File to use as glossary index',\n                    'pattern': FILENAME_REGEX\n                },\n                'summary': {\n                    'default': 'SUMMARY.md',\n                    'type': 'string',\n                    'title': 'File to use as table of contents',\n                    'pattern': FILENAME_REGEX\n                }\n            },\n            'additionalProperties': false\n        },\n        'pdf': {\n            'type': 'object',\n            'title': 'PDF specific configurations',\n            'properties': {\n                'pageNumbers': {\n                    'type': 'boolean',\n                    'default': true,\n                    'title': 'Add page numbers to the bottom of every page'\n                },\n                'fontSize': {\n                    'type': 'integer',\n                    'minimum': 8,\n                    'maximum': 30,\n                    'default': 12,\n                    'title': 'Font size for the PDF output'\n                },\n                'fontFamily': {\n                    'type': 'string',\n                    'default': 'Arial',\n                    'title': 'Font family for the PDF output'\n                },\n                'paperSize': {\n                    'type': 'string',\n                    'enum': ['a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'legal', 'letter'],\n                    'default': 'a4',\n                    'title': 'Paper size for the PDF'\n                },\n                'chapterMark': {\n                    'type': 'string',\n                    'enum': ['pagebreak', 'rule', 'both', 'none'],\n                    'default': 'pagebreak',\n                    'title': 'How to mark detected chapters'\n                },\n                'pageBreaksBefore': {\n                    'type': 'string',\n                    'default': '/',\n                    'title': 'An XPath expression. Page breaks are inserted before the specified elements. To disable use the expression: \"/\"'\n                },\n                'margin': {\n                    'type': 'object',\n                    'properties': {\n                        'right': {\n                            'type': 'integer',\n                            'title': 'Right Margin',\n                            'minimum': 0,\n                            'maximum': 100,\n                            'default': 62\n                        },\n                        'left': {\n                            'type': 'integer',\n                            'title': 'Left Margin',\n                            'minimum': 0,\n                            'maximum': 100,\n                            'default': 62\n                        },\n                        'top': {\n                            'type': 'integer',\n                            'title': 'Top Margin',\n                            'minimum': 0,\n                            'maximum': 100,\n                            'default': 56\n                        },\n                        'bottom': {\n                            'type': 'integer',\n                            'title': 'Bottom Margin',\n                            'minimum': 0,\n                            'maximum': 100,\n                            'default': 56\n                        }\n                    }\n                }\n            }\n        }\n    },\n    'required': [],\n    'definitions': {\n        'pluginsArray': {\n            'type': 'array',\n            'items': {\n                'oneOf': [\n                    { '$ref': '#/definitions/pluginObject' },\n                    { '$ref': '#/definitions/pluginString' }\n                ]\n            }\n        },\n        'pluginsString': {\n            'type': 'string'\n        },\n        'pluginString': {\n            'type': 'string'\n        },\n        'pluginObject': {\n            'type': 'object',\n            'properties': {\n                'name': {\n                    'type': 'string'\n                },\n                'version': {\n                    'type': 'string'\n                }\n            },\n            'additionalProperties': false,\n            'required': ['name']\n        }\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/reducedObject.js":"var Immutable = require('immutable');\n\n/**\n *  Reduce the difference between a map and its default version\n *  @param {Map} defaultVersion\n *  @param {Map} currentVersion\n *  @return {Map} The properties of currentVersion that differs from defaultVersion\n */\nfunction reducedObject(defaultVersion, currentVersion) {\n    if(defaultVersion === undefined) {\n        return currentVersion;\n    }\n\n    return currentVersion.reduce(function(result, value, key) {\n        var defaultValue = defaultVersion.get(key);\n\n        if (Immutable.Map.isMap(value)) {\n            var diffs = reducedObject(defaultValue, value);\n\n            if (diffs.size > 0) {\n                return result.set(key, diffs);\n            }\n        }\n\n        if (Immutable.is(defaultValue, value)) {\n            return result;\n        }\n\n        return result.set(key, value);\n    }, Immutable.Map());\n}\n\nmodule.exports = reducedObject;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/readme.js":"var Immutable = require('immutable');\n\nvar File = require('./file');\n\nvar Readme = Immutable.Record({\n    file:           File(),\n    title:          String(),\n    description:    String()\n});\n\nReadme.prototype.getFile = function() {\n    return this.get('file');\n};\n\nReadme.prototype.getTitle = function() {\n    return this.get('title');\n};\n\nReadme.prototype.getDescription = function() {\n    return this.get('description');\n};\n\n/**\n    Create a new readme\n\n    @param {File} file\n    @param {Object} def\n    @return {Readme}\n*/\nReadme.create = function(file, def) {\n    def = def || {};\n\n    return new Readme({\n        file: file,\n        title: def.title || '',\n        description: def.description || ''\n    });\n};\n\nmodule.exports = Readme;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/summary.js":"var is = require('is');\nvar Immutable = require('immutable');\n\nvar error = require('../utils/error');\nvar LocationUtils = require('../utils/location');\nvar File = require('./file');\nvar SummaryPart = require('./summaryPart');\nvar SummaryArticle = require('./summaryArticle');\nvar parsers = require('../parsers');\n\nvar Summary = Immutable.Record({\n    file:       File(),\n    parts:      Immutable.List()\n}, 'Summary');\n\nSummary.prototype.getFile = function() {\n    return this.get('file');\n};\n\nSummary.prototype.getParts = function() {\n    return this.get('parts');\n};\n\n/**\n    Return a part by its index\n\n    @param {Number}\n    @return {Part}\n*/\nSummary.prototype.getPart = function(i) {\n    var parts = this.getParts();\n    return parts.get(i);\n};\n\n/**\n    Return an article using an iterator to find it.\n    if \"partIter\" is set, it can also return a Part.\n\n    @param {Function} iter\n    @param {Function} partIter\n    @return {Article|Part}\n*/\nSummary.prototype.getArticle = function(iter, partIter) {\n    var parts = this.getParts();\n\n    return parts.reduce(function(result, part) {\n        if (result) return result;\n\n        if (partIter && partIter(part)) return part;\n        return SummaryArticle.findArticle(part, iter);\n    }, null);\n};\n\n\n/**\n    Return a part/article by its level\n\n    @param {String} level\n    @return {Article|Part}\n*/\nSummary.prototype.getByLevel = function(level) {\n    function iterByLevel(article) {\n        return (article.getLevel() === level);\n    }\n\n    return this.getArticle(iterByLevel, iterByLevel);\n};\n\n/**\n    Return an article by its path\n\n    @param {String} filePath\n    @return {Article}\n*/\nSummary.prototype.getByPath = function(filePath) {\n    return this.getArticle(function(article) {\n        var articlePath = article.getPath();\n\n        return (\n            articlePath &&\n            LocationUtils.areIdenticalPaths(articlePath, filePath)\n        );\n    });\n};\n\n/**\n    Return the first article\n\n    @return {Article}\n*/\nSummary.prototype.getFirstArticle = function() {\n    return this.getArticle(function(article) {\n        return true;\n    });\n};\n\n/**\n    Return next article of an article\n\n    @param {Article} current\n    @return {Article}\n*/\nSummary.prototype.getNextArticle = function(current) {\n    var level = is.string(current)? current : current.getLevel();\n    var wasPrev = false;\n\n    return this.getArticle(function(article) {\n        if (wasPrev) return true;\n\n        wasPrev = article.getLevel() == level;\n        return false;\n    });\n};\n\n/**\n    Return previous article of an article\n\n    @param {Article} current\n    @return {Article}\n*/\nSummary.prototype.getPrevArticle = function(current) {\n    var level = is.string(current)? current : current.getLevel();\n    var prev = undefined;\n\n    this.getArticle(function(article) {\n        if (article.getLevel() == level) {\n            return true;\n        }\n\n        prev = article;\n        return false;\n    });\n\n    return prev;\n};\n\n/**\n    Return the parent article, or parent part of an article\n\n    @param {String|Article} current\n    @return {Article|Part|Null}\n*/\nSummary.prototype.getParent = function (level) {\n    // Coerce to level\n    level = is.string(level)? level : level.getLevel();\n\n    // Get parent level\n    var parentLevel = getParentLevel(level);\n    if (!parentLevel) {\n        return null;\n    }\n\n    // Get parent of the position\n    var parentArticle = this.getByLevel(parentLevel);\n    return parentArticle || null;\n};\n\n/**\n    Render summary as text\n\n    @param {String} parseExt Extension of the parser to use\n    @return {Promise<String>}\n*/\nSummary.prototype.toText = function(parseExt) {\n    var file = this.getFile();\n    var parts = this.getParts();\n\n    var parser = parseExt? parsers.getByExt(parseExt) : file.getParser();\n\n    if (!parser) {\n        throw error.FileNotParsableError({\n            filename: file.getPath()\n        });\n    }\n\n    return parser.renderSummary({\n        parts: parts.toJS()\n    });\n};\n\n/**\n    Return all articles as a list\n\n    @return {List<Article>}\n*/\nSummary.prototype.getArticlesAsList = function() {\n    var accu = [];\n\n    this.getArticle(function(article) {\n        accu.push(article);\n    });\n\n    return Immutable.List(accu);\n};\n\n/**\n    Create a new summary for a list of parts\n\n    @param {Lust|Array} parts\n    @return {Summary}\n*/\nSummary.createFromParts = function createFromParts(file, parts) {\n    parts = parts.map(function(part, i) {\n        if (part instanceof SummaryPart) {\n            return part;\n        }\n\n        return SummaryPart.create(part, i + 1);\n    });\n\n    return new Summary({\n        file: file,\n        parts: new Immutable.List(parts)\n    });\n};\n\n/**\n    Returns parent level of a level\n\n    @param {String} level\n    @return {String}\n*/\nfunction getParentLevel(level) {\n    var parts = level.split('.');\n    return parts.slice(0, -1).join('.');\n}\n\nmodule.exports = Summary;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/glossary.js":"var Immutable = require('immutable');\n\nvar error = require('../utils/error');\nvar File = require('./file');\nvar GlossaryEntry = require('./glossaryEntry');\nvar parsers = require('../parsers');\n\nvar Glossary = Immutable.Record({\n    file:       File(),\n    entries:    Immutable.OrderedMap()\n});\n\nGlossary.prototype.getFile = function() {\n    return this.get('file');\n};\n\nGlossary.prototype.getEntries = function() {\n    return this.get('entries');\n};\n\n/**\n    Return an entry by its name\n\n    @param {String} name\n    @return {GlossaryEntry}\n*/\nGlossary.prototype.getEntry = function(name) {\n    var entries = this.getEntries();\n    var id = GlossaryEntry.nameToID(name);\n\n    return entries.get(id);\n};\n\n/**\n    Render glossary as text\n\n    @return {Promise<String>}\n*/\nGlossary.prototype.toText = function(parser) {\n    var file = this.getFile();\n    var entries = this.getEntries();\n\n    parser = parser? parsers.getByExt(parser) : file.getParser();\n\n    if (!parser) {\n        throw error.FileNotParsableError({\n            filename: file.getPath()\n        });\n    }\n\n    return parser.renderGlossary(entries.toJS());\n};\n\n\n/**\n    Add/Replace an entry to a glossary\n\n    @param {Glossary} glossary\n    @param {GlossaryEntry} entry\n    @return {Glossary}\n*/\nGlossary.addEntry = function addEntry(glossary, entry) {\n    var id = entry.getID();\n    var entries = glossary.getEntries();\n\n    entries = entries.set(id, entry);\n    return glossary.set('entries', entries);\n};\n\n/**\n    Add/Replace an entry to a glossary by name/description\n\n    @param {Glossary} glossary\n    @param {GlossaryEntry} entry\n    @return {Glossary}\n*/\nGlossary.addEntryByName = function addEntryByName(glossary, name, description) {\n    var entry = new GlossaryEntry({\n        name: name,\n        description: description\n    });\n\n    return Glossary.addEntry(glossary, entry);\n};\n\n/**\n    Create a glossary from a list of entries\n\n    @param {String} filename\n    @param {Array|List} entries\n    @return {Glossary}\n*/\nGlossary.createFromEntries = function createFromEntries(file, entries) {\n    entries = entries.map(function(entry) {\n        if (!(entry instanceof GlossaryEntry)) {\n            entry = new GlossaryEntry(entry);\n        }\n\n        return [entry.getID(), entry];\n    });\n\n    return new Glossary({\n        file: file,\n        entries: Immutable.OrderedMap(entries)\n    });\n};\n\n\nmodule.exports = Glossary;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/glossaryEntry.js":"var Immutable = require('immutable');\nvar slug = require('github-slugid');\n\n/*\n    A definition represents an entry in the glossary\n*/\n\nvar GlossaryEntry = Immutable.Record({\n    name:               String(),\n    description:        String()\n});\n\nGlossaryEntry.prototype.getName = function() {\n    return this.get('name');\n};\n\nGlossaryEntry.prototype.getDescription = function() {\n    return this.get('description');\n};\n\n\n/**\n    Get identifier for this entry\n\n    @retrun {Boolean}\n*/\nGlossaryEntry.prototype.getID = function() {\n    return GlossaryEntry.nameToID(this.getName());\n};\n\n\n/**\n    Normalize a glossary entry name into a unique id\n\n    @param {String}\n    @return {String}\n*/\nGlossaryEntry.nameToID = function nameToID(name) {\n    return slug(name);\n};\n\n\nmodule.exports = GlossaryEntry;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/languages.js":"var Immutable = require('immutable');\n\nvar File = require('./file');\nvar Language = require('./language');\n\nvar Languages = Immutable.Record({\n    file:       File(),\n    list:       Immutable.OrderedMap()\n});\n\nLanguages.prototype.getFile = function() {\n    return this.get('file');\n};\n\nLanguages.prototype.getList = function() {\n    return this.get('list');\n};\n\n/**\n    Get default languages\n\n    @return {Language}\n*/\nLanguages.prototype.getDefaultLanguage = function() {\n    return this.getList().first();\n};\n\n/**\n    Get a language by its ID\n\n    @param {String} lang\n    @return {Language}\n*/\nLanguages.prototype.getLanguage = function(lang) {\n    return this.getList().get(lang);\n};\n\n/**\n    Return count of langs\n\n    @return {Number}\n*/\nLanguages.prototype.getCount = function() {\n    return this.getList().size;\n};\n\n/**\n    Create a languages list from a JS object\n\n    @param {File}\n    @param {Array}\n    @return {Language}\n*/\nLanguages.createFromList = function(file, langs) {\n    var list = Immutable.OrderedMap();\n\n    langs.forEach(function(lang) {\n        lang = Language({\n            title: lang.title,\n            path: lang.ref\n        });\n        list = list.set(lang.getID(), lang);\n    });\n\n    return Languages({\n        file: file,\n        list: list\n    });\n};\n\nmodule.exports = Languages;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/language.js":"var path = require('path');\nvar Immutable = require('immutable');\n\nvar Language = Immutable.Record({\n    title:      String(),\n    path:       String()\n});\n\nLanguage.prototype.getTitle = function() {\n    return this.get('title');\n};\n\nLanguage.prototype.getPath = function() {\n    return this.get('path');\n};\n\nLanguage.prototype.getID = function() {\n    return path.basename(this.getPath());\n};\n\nmodule.exports = Language;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/ignore.js":"var Immutable = require('immutable');\nvar IgnoreMutable = require('ignore');\n\n/*\n    Immutable version of node-ignore\n*/\nvar Ignore = Immutable.Record({\n    ignore: new IgnoreMutable()\n}, 'Ignore');\n\nIgnore.prototype.getIgnore = function() {\n    return this.get('ignore');\n};\n\n/**\n    Test if a file is ignored by these rules\n\n    @param {String} filePath\n    @return {Boolean}\n*/\nIgnore.prototype.isFileIgnored = function(filename) {\n    var ignore = this.getIgnore();\n    return ignore.filter([filename]).length == 0;\n};\n\n/**\n    Add rules\n\n    @param {String}\n    @return {Ignore}\n*/\nIgnore.prototype.add = function(rule) {\n    var ignore = this.getIgnore();\n    var newIgnore = new IgnoreMutable();\n\n    newIgnore.add(ignore);\n    newIgnore.add(rule);\n\n    return this.set('ignore', newIgnore);\n};\n\nmodule.exports = Ignore;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/parseIgnore.js":"var Promise = require('../utils/promise');\nvar IGNORE_FILES = require('../constants/ignoreFiles');\n\nvar DEFAULT_IGNORES = [\n    // Skip Git stuff\n    '.git/',\n\n    // Skip OS X meta data\n    '.DS_Store',\n\n    // Skip stuff installed by plugins\n    'node_modules',\n\n    // Skip book outputs\n    '_book',\n\n    // Ignore files in the templates folder\n    '_layouts'\n];\n\n/**\n    Parse ignore files\n\n    @param {Book}\n    @return {Book}\n*/\nfunction parseIgnore(book) {\n    if (book.isLanguageBook()) {\n        return Promise.reject(new Error('Ignore files could be parsed for language books'));\n    }\n\n    var fs = book.getFS();\n    var ignore = book.getIgnore();\n\n    ignore = ignore.add(DEFAULT_IGNORES);\n\n    return Promise.serie(IGNORE_FILES, function(filename) {\n        return fs.readAsString(filename)\n        .then(function(content) {\n            ignore = ignore.add(content.toString().split(/\\r?\\n/));\n        }, function(err) {\n            return Promise();\n        });\n    })\n\n    .then(function() {\n        return book.setIgnore(ignore);\n    });\n}\n\nmodule.exports = parseIgnore;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/ignoreFiles.js":"// Files containing ignore pattner (sorted by priority)\nmodule.exports = [\n    '.ignore',\n    '.gitignore',\n    '.bookignore'\n];\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/parseConfig.js":"var Promise = require('../utils/promise');\n\nvar validateConfig = require('./validateConfig');\nvar CONFIG_FILES = require('../constants/configFiles');\n\n/**\n    Parse configuration from \"book.json\" or \"book.js\"\n\n    @param {Book} book\n    @return {Promise<Book>}\n*/\nfunction parseConfig(book) {\n    var fs = book.getFS();\n    var config = book.getConfig();\n\n    return Promise.some(CONFIG_FILES, function(filename) {\n        // Is this file ignored?\n        if (book.isFileIgnored(filename)) {\n            return;\n        }\n\n        // Try loading it\n        return fs.loadAsObject(filename)\n        .then(function(cfg) {\n            return fs.statFile(filename)\n            .then(function(file) {\n                return {\n                    file: file,\n                    values: cfg\n                };\n            });\n        })\n        .fail(function(err) {\n            if (err.code != 'MODULE_NOT_FOUND') throw(err);\n            else return Promise(false);\n        });\n    })\n\n    .then(function(result) {\n        var values = result? result.values : {};\n        values = validateConfig(values);\n\n        // Set the file\n        if (result.file) {\n            config = config.setFile(result.file);\n        }\n\n        // Merge with old values\n        config = config.mergeValues(values);\n\n        return book.setConfig(config);\n    });\n}\n\nmodule.exports = parseConfig;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/validateConfig.js":"var jsonschema = require('jsonschema');\nvar jsonSchemaDefaults = require('json-schema-defaults');\n\nvar schema = require('../constants/configSchema');\nvar error = require('../utils/error');\nvar mergeDefaults = require('../utils/mergeDefaults');\n\n/**\n    Validate a book.json content\n    And return a mix with the default value\n\n    @param {Object} bookJson\n    @return {Object}\n*/\nfunction validateConfig(bookJson) {\n    var v = new jsonschema.Validator();\n    var result = v.validate(bookJson, schema, {\n        propertyName: 'config'\n    });\n\n    // Throw error\n    if (result.errors.length > 0) {\n        throw new error.ConfigurationError(new Error(result.errors[0].stack));\n    }\n\n    // Insert default values\n    var defaults = jsonSchemaDefaults(schema);\n    return mergeDefaults(bookJson, defaults);\n}\n\nmodule.exports = validateConfig;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/mergeDefaults.js":"var Immutable = require('immutable');\n\n/**\n * Merge\n * @param  {Object|Map} obj\n * @param  {Object|Map} src\n * @return {Object}\n */\nfunction mergeDefaults(obj, src) {\n    var objValue = Immutable.fromJS(obj);\n    var srcValue = Immutable.fromJS(src);\n\n    return srcValue.mergeDeep(objValue).toJS();\n}\n\nmodule.exports = mergeDefaults;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/configFiles.js":"// Configuration files to test (sorted)\nmodule.exports = [\n    'book.js',\n    'book.json'\n];\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/parseGlossary.js":"var parseStructureFile = require('./parseStructureFile');\nvar Glossary = require('../models/glossary');\n\n/**\n    Parse glossary\n\n    @param {Book} book\n    @return {Promise<Book>}\n*/\nfunction parseGlossary(book) {\n    var logger = book.getLogger();\n\n    return parseStructureFile(book, 'glossary')\n    .spread(function(file, entries) {\n        if (!file) {\n            return book;\n        }\n\n        logger.debug.ln('glossary index file found at', file.getPath());\n\n        var glossary = Glossary.createFromEntries(file, entries);\n        return book.set('glossary', glossary);\n    });\n}\n\nmodule.exports = parseGlossary;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/parseStructureFile.js":"var Promise = require('../utils/promise');\nvar error = require('../utils/error');\nvar lookupStructureFile = require('./lookupStructureFile');\n\n/**\n    Parse a ParsableFile using a specific method\n\n    @param {FS} fs\n    @param {ParsableFile} file\n    @param {String} type\n    @return {Promise<Array<String, List|Map>>}\n*/\nfunction parseFile(fs, file, type) {\n    var filepath = file.getPath();\n    var parser = file.getParser();\n\n    if (!parser) {\n        return Promise.reject(\n            error.FileNotParsableError({\n                filename: filepath\n            })\n        );\n    }\n\n    return fs.readAsString(filepath)\n    .then(function(content) {\n        if (type === 'readme') {\n            return parser.parseReadme(content);\n        } else if (type === 'glossary') {\n            return parser.parseGlossary(content);\n        } else if (type === 'summary') {\n            return parser.parseSummary(content);\n        } else if (type === 'langs') {\n            return parser.parseLanguages(content);\n        } else {\n            throw new Error('Parsing invalid type \"' + type + '\"');\n        }\n    })\n    .then(function(result) {\n        return [\n            file,\n            result\n        ];\n    });\n}\n\n\n/**\n    Parse a structure file (ex: SUMMARY.md, GLOSSARY.md).\n    It uses the configuration to find the specified file.\n\n    @param {Book} book\n    @param {String} type: one of [\"glossary\", \"readme\", \"summary\"]\n    @return {Promise<List|Map>}\n*/\nfunction parseStructureFile(book, type) {\n    var fs = book.getContentFS();\n\n    return lookupStructureFile(book, type)\n    .then(function(file) {\n        if (!file) return [undefined, undefined];\n\n        return parseFile(fs, file, type);\n    });\n}\n\nmodule.exports = parseStructureFile;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/lookupStructureFile.js":"var findParsableFile = require('./findParsableFile');\n\n/**\n    Lookup a structure file (ex: SUMMARY.md, GLOSSARY.md) in a book. Uses\n    book's config to find it.\n\n    @param {Book} book\n    @param {String} type: one of [\"glossary\", \"readme\", \"summary\", \"langs\"]\n    @return {Promise<File | Undefined>} The path of the file found, relative\n    to the book content root.\n*/\nfunction lookupStructureFile(book, type) {\n    var config = book.getConfig();\n\n    var fileToSearch = config.getValue(['structure', type]);\n\n    return findParsableFile(book, fileToSearch);\n}\n\nmodule.exports = lookupStructureFile;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/findParsableFile.js":"var path = require('path');\n\nvar Promise = require('../utils/promise');\nvar parsers = require('../parsers');\n\n/**\n    Find a file parsable (Markdown or AsciiDoc) in a book\n\n    @param {Book} book\n    @param {String} filename\n    @return {Promise<File | Undefined>}\n*/\nfunction findParsableFile(book, filename) {\n    var fs = book.getContentFS();\n    var ext = path.extname(filename);\n    var basename = path.basename(filename, ext);\n    var basedir = path.dirname(filename);\n\n    // Ordered list of extensions to test\n    var exts = parsers.extensions;\n\n    return Promise.some(exts, function(ext) {\n        var filepath = basename + ext;\n\n        return fs.findFile(basedir, filepath)\n        .then(function(found) {\n            if (!found || book.isContentFileIgnored(found)) {\n                return undefined;\n            }\n\n            return fs.statFile(found);\n        });\n    });\n}\n\nmodule.exports = findParsableFile;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/parseSummary.js":"var parseStructureFile = require('./parseStructureFile');\nvar Summary = require('../models/summary');\nvar SummaryModifier = require('../modifiers').Summary;\n\n/**\n    Parse summary in a book, the summary can only be parsed\n    if the readme as be detected before.\n\n    @param {Book} book\n    @return {Promise<Book>}\n*/\nfunction parseSummary(book) {\n    var readme = book.getReadme();\n    var logger = book.getLogger();\n    var readmeFile = readme.getFile();\n\n    return parseStructureFile(book, 'summary')\n    .spread(function(file, result) {\n        var summary;\n\n        if (!file) {\n            logger.warn.ln('no summary file in this book');\n            summary = Summary();\n        } else {\n            logger.debug.ln('summary file found at', file.getPath());\n            summary = Summary.createFromParts(file, result.parts);\n        }\n\n        // Insert readme as first entry if not in SUMMARY.md\n        var readmeArticle = summary.getByPath(readmeFile.getPath());\n\n        if (readmeFile.exists() && !readmeArticle) {\n            summary = SummaryModifier.unshiftArticle(summary, {\n                title: 'Introduction',\n                ref: readmeFile.getPath()\n            });\n        }\n\n        // Set new summary\n        return book.setSummary(summary);\n    });\n}\n\nmodule.exports = parseSummary;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/parseReadme.js":"var parseStructureFile = require('./parseStructureFile');\nvar Readme = require('../models/readme');\n\nvar error = require('../utils/error');\n\n/**\n    Parse readme from book\n\n    @param {Book} book\n    @return {Promise<Book>}\n*/\nfunction parseReadme(book) {\n    var logger = book.getLogger();\n\n    return parseStructureFile(book, 'readme')\n    .spread(function(file, result) {\n        if (!file) {\n            throw new error.FileNotFoundError({ filename: 'README' });\n        }\n\n        logger.debug.ln('readme found at', file.getPath());\n\n        var readme = Readme.create(file, result);\n        return book.set('readme', readme);\n    });\n}\n\nmodule.exports = parseReadme;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/parseLanguages.js":"var parseStructureFile = require('./parseStructureFile');\nvar Languages = require('../models/languages');\n\n/**\n    Parse languages list from book\n\n    @param {Book} book\n    @return {Promise<Book>}\n*/\nfunction parseLanguages(book) {\n    var logger = book.getLogger();\n\n    return parseStructureFile(book, 'langs')\n    .spread(function(file, result) {\n        if (!file) {\n            return book;\n        }\n\n        var languages = Languages.createFromList(file, result);\n\n        logger.debug.ln('languages index file found at', file.getPath());\n        logger.info.ln('parsing multilingual book, with', languages.getList().size, 'languages');\n\n        return book.set('languages', languages);\n    });\n}\n\nmodule.exports = parseLanguages;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/parsePagesList.js":"var Immutable = require('immutable');\n\nvar timing = require('../utils/timing');\nvar Page = require('../models/page');\nvar walkSummary = require('./walkSummary');\nvar parsePage = require('./parsePage');\n\n\n/**\n    Parse a page from a path\n\n    @param {Book} book\n    @param {String} filePath\n    @return {Page?}\n*/\nfunction parseFilePage(book, filePath) {\n    var fs = book.getContentFS();\n\n    return fs.statFile(filePath)\n    .then(\n        function(file) {\n            var page = Page.createForFile(file);\n            return parsePage(book, page);\n        },\n        function(err) {\n            // file doesn't exist\n            return null;\n        }\n    )\n    .fail(function(err) {\n        var logger = book.getLogger();\n        logger.error.ln('error while parsing page \"' + filePath + '\":');\n        throw err;\n    });\n}\n\n\n/**\n    Parse all pages from a book as an OrderedMap\n\n    @param {Book} book\n    @return {Promise<OrderedMap<Page>>}\n*/\nfunction parsePagesList(book) {\n    var summary = book.getSummary();\n    var glossary = book.getGlossary();\n    var map = Immutable.OrderedMap();\n\n    // Parse pages from summary\n    return timing.measure(\n        'parse.listPages',\n        walkSummary(summary, function(article) {\n            if (!article.isPage()) return;\n\n            var filepath = article.getPath();\n\n            // Is the page ignored?\n            if (book.isContentFileIgnored(filepath)) return;\n\n            return parseFilePage(book, filepath)\n            .then(function(page) {\n                // file doesn't exist\n                if (!page) {\n                    return;\n                }\n\n                map = map.set(filepath, page);\n            });\n        })\n    )\n\n    // Parse glossary\n    .then(function() {\n        var file = glossary.getFile();\n\n        if (!file.exists()) {\n            return;\n        }\n\n        return parseFilePage(book, file.getPath())\n        .then(function(page) {\n            // file doesn't exist\n            if (!page) {\n                return;\n            }\n\n            map = map.set(file.getPath(), page);\n        });\n    })\n\n    .then(function() {\n        return map;\n    });\n}\n\n\nmodule.exports = parsePagesList;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/page.js":"var Immutable = require('immutable');\nvar yaml = require('js-yaml');\n\nvar File = require('./file');\n\nvar Page = Immutable.Record({\n    file:           File(),\n\n    // Attributes extracted from the YAML header\n    attributes:     Immutable.Map(),\n\n    // Content of the page\n    content:        String(),\n\n    // Direction of the text\n    dir:            String('ltr')\n});\n\nPage.prototype.getFile = function() {\n    return this.get('file');\n};\n\nPage.prototype.getAttributes = function() {\n    return this.get('attributes');\n};\n\nPage.prototype.getContent = function() {\n    return this.get('content');\n};\n\nPage.prototype.getDir = function() {\n    return this.get('dir');\n};\n\n/**\n * Return page as text\n * @return {String}\n*/\nPage.prototype.toText = function() {\n    var attrs = this.getAttributes();\n    var content = this.getContent();\n\n    if (attrs.size === 0) {\n        return content;\n    }\n\n    var frontMatter = '---\\n' + yaml.safeDump(attrs.toJS(), { skipInvalid: true }) + '---\\n\\n';\n    return (frontMatter + content);\n};\n\n/**\n * Return path of the page\n * @return {String}\n*/\nPage.prototype.getPath = function() {\n    return this.getFile().getPath();\n};\n\n/**\n * Create a page for a file\n * @param {File} file\n * @return {Page}\n*/\nPage.createForFile = function(file) {\n    return new Page({\n        file: file\n    });\n};\n\nmodule.exports = Page;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/walkSummary.js":"var Promise = require('../utils/promise');\n\n/**\n    Walk over a list of articles\n\n    @param {List<Article>} articles\n    @param {Function(article)}\n    @return {Promise}\n*/\nfunction walkArticles(articles, fn) {\n    return Promise.forEach(articles, function(article) {\n        return Promise(fn(article))\n        .then(function() {\n            return walkArticles(article.getArticles(), fn);\n        });\n    });\n}\n\n/**\n    Walk over summary and execute \"fn\" on each article\n\n    @param {Summary} summary\n    @param {Function(article)}\n    @return {Promise}\n*/\nfunction walkSummary(summary, fn) {\n    var parts = summary.getParts();\n\n    return Promise.forEach(parts, function(part) {\n        return walkArticles(part.getArticles(), fn);\n    });\n}\n\nmodule.exports = walkSummary;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/parsePage.js":"var parsePageFromString = require('./parsePageFromString');\n\n/**\n * Parse a page, read its content and parse the YAMl header\n *\n * @param {Book} book\n * @param {Page} page\n * @return {Promise<Page>}\n */\nfunction parsePage(book, page) {\n    var fs = book.getContentFS();\n    var file = page.getFile();\n\n    return fs.readAsString(file.getPath())\n    .then(function(content) {\n        return parsePageFromString(page, content);\n    });\n}\n\n\nmodule.exports = parsePage;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/parsePageFromString.js":"var Immutable = require('immutable');\nvar fm = require('front-matter');\nvar direction = require('direction');\n\n/**\n * Parse a page, its content and the YAMl header\n *\n * @param {Page} page\n * @return {Page}\n */\nfunction parsePageFromString(page, content) {\n    // Parse page YAML\n    var parsed = fm(content);\n\n    return page.merge({\n        content:    parsed.body,\n        attributes: Immutable.fromJS(parsed.attributes),\n        dir:        direction(parsed.body)\n    });\n}\n\n\nmodule.exports = parsePageFromString;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/parse/listAssets.js":"var timing = require('../utils/timing');\n\n/**\n    List all assets in a book\n    Assets are file not ignored and not a page\n\n    @param {Book} book\n    @param {List<String>} pages\n    @param\n*/\nfunction listAssets(book, pages) {\n    var fs = book.getContentFS();\n\n    var summary = book.getSummary();\n    var summaryFile = summary.getFile().getPath();\n\n    var glossary = book.getGlossary();\n    var glossaryFile = glossary.getFile().getPath();\n\n    var langs = book.getLanguages();\n    var langsFile = langs.getFile().getPath();\n\n    var config = book.getConfig();\n    var configFile = config.getFile().getPath();\n\n    function filterFile(file) {\n        return !(\n            file === summaryFile ||\n            file === glossaryFile ||\n            file === langsFile ||\n            file === configFile ||\n            book.isContentFileIgnored(file) ||\n            pages.has(file)\n        );\n    }\n\n    return timing.measure(\n        'parse.listAssets',\n        fs.listAllFiles('.', filterFile)\n    );\n}\n\nmodule.exports = listAssets;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/init.js":"var path = require('path');\n\nvar createNodeFS = require('./fs/node');\nvar fs = require('./utils/fs');\nvar Promise = require('./utils/promise');\nvar File = require('./models/file');\nvar Readme = require('./models/readme');\nvar Book = require('./models/book');\nvar Parse = require('./parse');\n\n/**\n    Initialize folder structure for a book\n    Read SUMMARY to created the right chapter\n\n    @param {Book}\n    @param {String}\n    @return {Promise}\n*/\nfunction initBook(rootFolder) {\n    var extension = '.md';\n\n    return fs.mkdirp(rootFolder)\n\n    // Parse the summary and readme\n    .then(function() {\n        var fs = createNodeFS(rootFolder);\n        var book = Book.createForFS(fs);\n\n        return Parse.parseReadme(book)\n\n        // Setup default readme if doesn't found one\n        .fail(function() {\n            var readmeFile = File.createWithFilepath('README' + extension);\n            var readme = Readme.create(readmeFile);\n            return book.setReadme(readme);\n        });\n    })\n    .then(Parse.parseSummary)\n\n    .then(function(book) {\n        var logger = book.getLogger();\n        var summary = book.getSummary();\n        var summaryFile = summary.getFile();\n        var summaryFilename = summaryFile.getPath() || ('SUMMARY' + extension);\n\n        var articles = summary.getArticlesAsList();\n\n        // Write pages\n        return Promise.forEach(articles, function(article) {\n            var articlePath = article.getPath();\n            var filePath = articlePath? path.join(rootFolder, articlePath) : null;\n            if (!filePath) {\n                return;\n            }\n\n            return fs.assertFile(filePath, function() {\n                return fs.ensureFile(filePath)\n                .then(function() {\n                    logger.info.ln('create', article.getPath());\n                    return fs.writeFile(filePath, '# ' + article.getTitle() + '\\n\\n');\n                });\n            });\n        })\n\n        // Write summary\n        .then(function() {\n            var filePath = path.join(rootFolder, summaryFilename);\n\n            return fs.ensureFile(filePath)\n            .then(function() {\n                logger.info.ln('create ' + path.basename(filePath));\n                return fs.writeFile(filePath, summary.toText(extension));\n            });\n        })\n\n        // Log end\n        .then(function() {\n            logger.info.ln('initialization is finished');\n        });\n    });\n}\n\nmodule.exports = initBook;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/fs/node.js":"var path = require('path');\nvar Immutable = require('immutable');\nvar fresh = require('fresh-require');\n\nvar fs = require('../utils/fs');\nvar FS = require('../models/fs');\n\nfunction fsReadDir(folder) {\n    return fs.readdir(folder)\n    .then(function(files) {\n        files = Immutable.List(files);\n\n        return files\n            .map(function(file) {\n                if (file == '.' || file == '..') return;\n\n                var stat = fs.statSync(path.join(folder, file));\n                if (stat.isDirectory()) file = file + path.sep;\n                return file;\n            })\n            .filter(function(file) {\n                return Boolean(file);\n            });\n    });\n}\n\nfunction fsLoadObject(filename) {\n    return fresh(filename, require);\n}\n\nmodule.exports = function createNodeFS(root) {\n    return FS.create({\n        root: root,\n\n        fsExists: fs.exists,\n        fsReadFile: fs.readFile,\n        fsStatFile: fs.stat,\n        fsReadDir: fsReadDir,\n        fsLoadObject: fsLoadObject,\n        fsReadAsStream: fs.readStream\n    });\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/fs.js":"var fs = require('graceful-fs');\nvar mkdirp = require('mkdirp');\nvar destroy = require('destroy');\nvar rmdir = require('rmdir');\nvar tmp = require('tmp');\nvar request = require('request');\nvar path = require('path');\nvar cp = require('cp');\nvar cpr = require('cpr');\n\nvar Promise = require('./promise');\n\n// Write a stream to a file\nfunction writeStream(filename, st) {\n    var d = Promise.defer();\n\n    var wstream = fs.createWriteStream(filename);\n    var cleanup = function() {\n        destroy(wstream);\n        wstream.removeAllListeners();\n    };\n\n    wstream.on('finish', function () {\n        cleanup();\n        d.resolve();\n    });\n    wstream.on('error', function (err) {\n        cleanup();\n        d.reject(err);\n    });\n\n    st.on('error', function(err) {\n        cleanup();\n        d.reject(err);\n    });\n\n    st.pipe(wstream);\n\n    return d.promise;\n}\n\n// Return a promise resolved with a boolean\nfunction fileExists(filename) {\n    var d = Promise.defer();\n\n    fs.exists(filename, function(exists) {\n        d.resolve(exists);\n    });\n\n    return d.promise;\n}\n\n// Generate temporary file\nfunction genTmpFile(opts) {\n    return Promise.nfcall(tmp.file, opts)\n        .get(0);\n}\n\n// Generate temporary dir\nfunction genTmpDir(opts) {\n    return Promise.nfcall(tmp.dir, opts)\n        .get(0);\n}\n\n// Download an image\nfunction download(uri, dest) {\n    return writeStream(dest, request(uri));\n}\n\n// Find a filename available in a folder\nfunction uniqueFilename(base, filename) {\n    var ext = path.extname(filename);\n    filename = path.resolve(base, filename);\n    filename = path.join(path.dirname(filename), path.basename(filename, ext));\n\n    var _filename = filename+ext;\n\n    var i = 0;\n    while (fs.existsSync(filename)) {\n        _filename = filename + '_' + i + ext;\n        i = i + 1;\n    }\n\n    return Promise(path.relative(base, _filename));\n}\n\n// Create all required folder to create a file\nfunction ensureFile(filename) {\n    var base = path.dirname(filename);\n    return Promise.nfcall(mkdirp, base);\n}\n\n// Remove a folder\nfunction rmDir(base) {\n    return Promise.nfcall(rmdir, base, {\n        fs: fs\n    });\n}\n\n/**\n    Assert a file, if it doesn't exist, call \"generator\"\n\n    @param {String} filePath\n    @param {Function} generator\n    @return {Promise}\n*/\nfunction assertFile(filePath, generator) {\n    return fileExists(filePath)\n    .then(function(exists) {\n        if (exists) return;\n\n        return generator();\n    });\n}\n\n/**\n    Pick a file, returns the absolute path if exists, undefined otherwise\n\n    @param {String} rootFolder\n    @param {String} fileName\n    @return {String}\n*/\nfunction pickFile(rootFolder, fileName) {\n    var result = path.join(rootFolder, fileName);\n    if (fs.existsSync(result)) {\n        return result;\n    }\n\n    return undefined;\n}\n\n/**\n    Ensure that a directory exists and is empty\n\n    @param {String} folder\n    @return {Promise}\n*/\nfunction ensureFolder(rootFolder) {\n    return rmDir(rootFolder)\n    .fail(function() {\n        return Promise();\n    })\n    .then(function() {\n        return Promise.nfcall(mkdirp, rootFolder);\n    });\n}\n\nmodule.exports = {\n    exists: fileExists,\n    existsSync: fs.existsSync,\n    mkdirp: Promise.nfbind(mkdirp),\n    readFile: Promise.nfbind(fs.readFile),\n    writeFile: Promise.nfbind(fs.writeFile),\n    assertFile: assertFile,\n    pickFile: pickFile,\n    stat: Promise.nfbind(fs.stat),\n    statSync: fs.statSync,\n    readdir: Promise.nfbind(fs.readdir),\n    writeStream: writeStream,\n    readStream: fs.createReadStream,\n    copy: Promise.nfbind(cp),\n    copyDir: Promise.nfbind(cpr),\n    tmpFile: genTmpFile,\n    tmpDir: genTmpDir,\n    download: download,\n    uniqueFilename: uniqueFilename,\n    ensureFile: ensureFile,\n    ensureFolder: ensureFolder,\n    rmDir: rmDir\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/index.js":"var Immutable = require('immutable');\n\nvar generators = Immutable.List([\n    require('./json'),\n    require('./website'),\n    require('./ebook')\n]);\n\n/**\n    Return a specific generator by its name\n\n    @param {String}\n    @return {Generator}\n*/\nfunction getGenerator(name) {\n    return generators.find(function(generator) {\n        return generator.name == name;\n    });\n}\n\nmodule.exports = {\n    generate:           require('./generateBook'),\n    getGenerator:       getGenerator\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/json/index.js":"\nmodule.exports = {\n    name:       'json',\n    Options:    require('./options'),\n    onPage:     require('./onPage'),\n    onFinish:   require('./onFinish')\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/json/options.js":"var Immutable = require('immutable');\n\nvar Options = Immutable.Record({\n    // Root folder for the output\n    root:       String()\n});\n\nmodule.exports = Options;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/json/onPage.js":"var JSONUtils = require('../../json');\nvar PathUtils = require('../../utils/path');\nvar Modifiers = require('../modifiers');\nvar writeFile = require('../helper/writeFile');\nvar getModifiers = require('../getModifiers');\n\nvar JSON_VERSION = '3';\n\n/**\n * Write a page as a json file\n *\n * @param {Output} output\n * @param {Page} page\n */\nfunction onPage(output, page) {\n    var file = page.getFile();\n    var readme = output.getBook().getReadme().getFile();\n\n    return Modifiers.modifyHTML(page, getModifiers(output, page))\n    .then(function(resultPage) {\n        // Generate the JSON\n        var json = JSONUtils.encodeBookWithPage(output.getBook(), resultPage);\n\n        // Delete some private properties\n        delete json.config;\n\n        // Specify JSON output version\n        json.version = JSON_VERSION;\n\n        // File path in the output folder\n        var filePath = file.getPath() == readme.getPath()? 'README.json' : file.getPath();\n        filePath = PathUtils.setExtension(filePath, '.json');\n\n        // Write it to the disk\n        return writeFile(\n            output,\n            filePath,\n            JSON.stringify(json, null, 4)\n        );\n    });\n}\n\nmodule.exports = onPage;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/index.js":"\nmodule.exports = {\n    encodeOutput:           require('./encodeOutput'),\n    encodeBookWithPage:     require('./encodeBookWithPage'),\n    encodeOutputWithPage:   require('./encodeOutputWithPage'),\n    encodeBook:             require('./encodeBook'),\n    encodeFile:             require('./encodeFile'),\n    encodePage:             require('./encodePage'),\n    encodeSummary:          require('./encodeSummary'),\n    encodeSummaryArticle:   require('./encodeSummaryArticle'),\n    encodeReadme:           require('./encodeReadme'),\n    encodeLanguages:        require('./encodeLanguages')\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodeOutput.js":"var encodeBook = require('./encodeBook');\n\n/**\n * Encode an output to JSON\n *\n * @param {Output}\n * @return {Object}\n */\nfunction encodeOutputToJson(output) {\n    var book = output.getBook();\n    var generator = output.getGenerator();\n    var options = output.getOptions();\n\n    var result = encodeBook(book);\n\n    result.output = {\n        name: generator\n    };\n\n    result.options = options.toJS();\n\n    return result;\n}\n\nmodule.exports = encodeOutputToJson;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodeBook.js":"var extend = require('extend');\n\nvar gitbook = require('../gitbook');\nvar encodeSummary = require('./encodeSummary');\nvar encodeGlossary = require('./encodeGlossary');\nvar encodeReadme = require('./encodeReadme');\nvar encodeLanguages = require('./encodeLanguages');\n\n/**\n    Encode a book to JSON\n\n    @param {Book}\n    @return {Object}\n*/\nfunction encodeBookToJson(book) {\n    var config = book.getConfig();\n    var language = book.getLanguage();\n\n    var variables = config.getValue('variables', {});\n\n    return {\n        summary: encodeSummary(book.getSummary()),\n        glossary: encodeGlossary(book.getGlossary()),\n        readme: encodeReadme(book.getReadme()),\n        config: book.getConfig().getValues().toJS(),\n\n        languages: book.isMultilingual()? encodeLanguages(book.getLanguages()) : undefined,\n\n        gitbook: {\n            version: gitbook.version,\n            time: gitbook.START_TIME\n        },\n        book: extend({\n            language: language? language : undefined\n        }, variables.toJS())\n    };\n}\n\nmodule.exports = encodeBookToJson;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/gitbook.js":"var semver = require('semver');\nvar pkg = require('../package.json');\n\nvar VERSION = pkg.version;\nvar VERSION_STABLE = VERSION.replace(/\\-(\\S+)/g, '');\n\nvar START_TIME = new Date();\n\n/**\n    Verify that this gitbook version satisfies a requirement\n    We can't directly use samver.satisfies since it will break all plugins when gitbook version is a prerelease (beta, alpha)\n\n    @param {String} condition\n    @return {Boolean}\n*/\nfunction satisfies(condition) {\n    // Test with real version\n    if (semver.satisfies(VERSION, condition)) return true;\n\n    // Test with future stable release\n    return semver.satisfies(VERSION_STABLE, condition);\n}\n\nmodule.exports = {\n    version: pkg.version,\n    satisfies: satisfies,\n    START_TIME: START_TIME\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodeSummary.js":"var encodeFile = require('./encodeFile');\nvar encodeSummaryPart = require('./encodeSummaryPart');\n\n/**\n    Encode a summary to JSON\n\n    @param {Summary}\n    @return {Object}\n*/\nfunction encodeSummary(summary) {\n    var file = summary.getFile();\n    var parts = summary.getParts();\n\n    return {\n        file: encodeFile(file),\n        parts: parts.map(encodeSummaryPart).toJS()\n    };\n}\n\nmodule.exports = encodeSummary;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodeFile.js":"\n/**\n    Return a JSON representation of a file\n\n    @param {File} file\n    @return {Object}\n*/\nfunction encodeFileToJson(file) {\n    var filePath = file.getPath();\n    if (!filePath) {\n        return undefined;\n    }\n\n    return {\n        path: filePath,\n        mtime: file.getMTime(),\n        type: file.getType()\n    };\n}\n\nmodule.exports = encodeFileToJson;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodeSummaryPart.js":"var encodeSummaryArticle = require('./encodeSummaryArticle');\n\n/**\n    Encode a SummaryPart to JSON\n\n    @param {SummaryPart}\n    @return {Object}\n*/\nfunction encodeSummaryPart(part) {\n    return {\n        title: part.getTitle(),\n        articles: part.getArticles()\n            .map(encodeSummaryArticle).toJS()\n    };\n}\n\nmodule.exports = encodeSummaryPart;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodeSummaryArticle.js":"\n/**\n    Encode a SummaryArticle to JSON\n\n    @param {SummaryArticle}\n    @return {Object}\n*/\nfunction encodeSummaryArticle(article, recursive) {\n    var articles = undefined;\n    if (recursive !== false) {\n        articles = article.getArticles()\n            .map(encodeSummaryArticle)\n            .toJS();\n    }\n\n    return {\n        title: article.getTitle(),\n        level: article.getLevel(),\n        depth: article.getDepth(),\n        anchor: article.getAnchor(),\n        url: article.getUrl(),\n        path: article.getPath(),\n        ref: article.getRef(),\n        articles: articles\n    };\n}\n\nmodule.exports = encodeSummaryArticle;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodeGlossary.js":"var encodeFile = require('./encodeFile');\nvar encodeGlossaryEntry = require('./encodeGlossaryEntry');\n\n/**\n    Encode a glossary to JSON\n\n    @param {Glossary}\n    @return {Object}\n*/\nfunction encodeGlossary(glossary) {\n    var file = glossary.getFile();\n    var entries = glossary.getEntries();\n\n    return {\n        file: encodeFile(file),\n        entries: entries\n            .map(encodeGlossaryEntry).toJS()\n    };\n}\n\nmodule.exports = encodeGlossary;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodeGlossaryEntry.js":"\n/**\n    Encode a SummaryArticle to JSON\n\n    @param {GlossaryEntry}\n    @return {Object}\n*/\nfunction encodeGlossaryEntry(entry) {\n    return {\n        id: entry.getID(),\n        name: entry.getName(),\n        description: entry.getDescription()\n    };\n}\n\nmodule.exports = encodeGlossaryEntry;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodeReadme.js":"var encodeFile = require('./encodeFile');\n\n/**\n    Encode a readme to JSON\n\n    @param {Readme}\n    @return {Object}\n*/\nfunction encodeReadme(readme) {\n    var file = readme.getFile();\n\n    return {\n        file: encodeFile(file)\n    };\n}\n\nmodule.exports = encodeReadme;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodeLanguages.js":"var encodeFile = require('./encodeFile');\n\n/**\n    Encode a languages listing to JSON\n\n    @param {Languages}\n    @return {Object}\n*/\nfunction encodeLanguages(languages) {\n    var file = languages.getFile();\n    var list = languages.getList();\n\n    return {\n        file: encodeFile(file),\n        list: list\n            .valueSeq()\n            .map(function(lang) {\n                return {\n                    id: lang.getID(),\n                    title: lang.getTitle()\n                };\n            }).toJS()\n    };\n}\n\nmodule.exports = encodeLanguages;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodeBookWithPage.js":"var encodeBook = require('./encodeBook');\nvar encodePage = require('./encodePage');\nvar encodeFile = require('./encodeFile');\n\n/**\n * Return a JSON representation of a book with a specific file\n *\n * @param {Book} output\n * @param {Page} page\n * @return {Object}\n */\nfunction encodeBookWithPage(book, page) {\n    var file = page.getFile();\n\n    var result = encodeBook(book);\n    result.page = encodePage(page, book.getSummary());\n    result.file = encodeFile(file);\n\n    return result;\n}\n\nmodule.exports = encodeBookWithPage;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodePage.js":"var encodeSummaryArticle = require('./encodeSummaryArticle');\n\n/**\n    Return a JSON representation of a page\n\n    @param {Page} page\n    @param {Summary} summary\n    @return {Object}\n*/\nfunction encodePage(page, summary) {\n    var file = page.getFile();\n    var attributes = page.getAttributes();\n    var article = summary.getByPath(file.getPath());\n\n    var result = attributes.toJS();\n\n    if (article) {\n        result.title = article.getTitle();\n        result.level = article.getLevel();\n        result.depth = article.getDepth();\n\n        var nextArticle = summary.getNextArticle(article);\n        if (nextArticle) {\n            result.next = encodeSummaryArticle(nextArticle);\n        }\n\n        var prevArticle = summary.getPrevArticle(article);\n        if (prevArticle) {\n            result.previous = encodeSummaryArticle(prevArticle);\n        }\n    }\n\n    result.content = page.getContent();\n    result.dir = page.getDir();\n\n    return result;\n}\n\nmodule.exports = encodePage;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/json/encodeOutputWithPage.js":"var encodeOutput = require('./encodeOutput');\nvar encodePage = require('./encodePage');\nvar encodeFile = require('./encodeFile');\n\n/**\n * Return a JSON representation of a book with a specific file\n *\n * @param {Book} output\n * @param {Page} page\n * @return {Object}\n */\nfunction encodeOutputWithPage(output, page) {\n    var file = page.getFile();\n    var book = output.getBook();\n\n    var result = encodeOutput(output);\n    result.page = encodePage(page, book.getSummary());\n    result.file = encodeFile(file);\n\n    return result;\n}\n\nmodule.exports = encodeOutputWithPage;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/index.js":"\nmodule.exports = {\n    modifyHTML:         require('./modifyHTML'),\n    inlineAssets:       require('./inlineAssets'),\n\n    // HTML transformations\n    addHeadingId:       require('./addHeadingId'),\n    svgToImg:           require('./svgToImg'),\n    fetchRemoteImages:  require('./fetchRemoteImages'),\n    svgToPng:           require('./svgToPng'),\n    resolveLinks:       require('./resolveLinks'),\n    resolveImages:      require('./resolveImages'),\n    annotateText:       require('./annotateText'),\n    highlightCode:      require('./highlightCode')\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/modifyHTML.js":"var cheerio = require('cheerio');\nvar Promise = require('../../utils/promise');\n\n/**\n    Apply a list of operations to a page and\n    output the new page.\n\n    @param {Page}\n    @param {List|Array<Transformation>}\n    @return {Promise<Page>}\n*/\nfunction modifyHTML(page, operations) {\n    var html = page.getContent();\n    var $ = cheerio.load(html);\n\n    return Promise.forEach(operations, function(op) {\n        return op($);\n    })\n    .then(function() {\n        var resultHTML = $.html();\n        return page.set('content', resultHTML);\n    });\n}\n\nmodule.exports = modifyHTML;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/inlineAssets.js":"var svgToImg = require('./svgToImg');\nvar svgToPng = require('./svgToPng');\nvar inlinePng = require('./inlinePng');\nvar resolveImages = require('./resolveImages');\nvar fetchRemoteImages = require('./fetchRemoteImages');\n\nvar Promise = require('../../utils/promise');\n\n/**\n    Inline all assets in a page\n\n    @param {String} rootFolder\n*/\nfunction inlineAssets(rootFolder, currentFile) {\n    return function($) {\n        return Promise()\n\n        // Resolving images and fetching external images should be\n        // done before svg conversion\n        .then(resolveImages.bind(null, currentFile, $))\n        .then(fetchRemoteImages.bind(null, rootFolder, currentFile, $))\n\n        .then(svgToImg.bind(null, rootFolder, currentFile, $))\n        .then(svgToPng.bind(null, rootFolder, currentFile, $))\n        .then(inlinePng.bind(null, rootFolder, currentFile, $));\n    };\n}\n\nmodule.exports = inlineAssets;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/svgToImg.js":"var path = require('path');\nvar crc = require('crc');\nvar domSerializer = require('dom-serializer');\n\nvar editHTMLElement = require('./editHTMLElement');\nvar fs = require('../../utils/fs');\nvar LocationUtils = require('../../utils/location');\n\n/**\n    Render a cheerio DOM as html\n\n    @param {HTMLDom} $\n    @param {HTMLElement} dom\n    @param {Object}\n    @return {String}\n*/\nfunction renderDOM($, dom, options) {\n    if (!dom && $._root && $._root.children) {\n        dom = $._root.children;\n    }\n    options = options|| dom.options || $._options;\n    return domSerializer(dom, options);\n}\n\n/**\n    Replace SVG tag by IMG\n\n    @param {String} baseFolder\n    @param {HTMLDom} $\n*/\nfunction svgToImg(baseFolder, currentFile, $) {\n    var currentDirectory = path.dirname(currentFile);\n\n    return editHTMLElement($, 'svg', function($svg) {\n        var content = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>' +\n            renderDOM($, $svg);\n\n        // We avoid generating twice the same PNG\n        var hash = crc.crc32(content).toString(16);\n        var fileName = hash + '.svg';\n        var filePath = path.join(baseFolder, fileName);\n\n        // Write the svg to the file\n        return fs.assertFile(filePath, function() {\n            return fs.writeFile(filePath, content, 'utf8');\n        })\n\n        // Return as image\n        .then(function() {\n            var src = LocationUtils.relative(currentDirectory, fileName);\n            $svg.replaceWith('<img src=\"' + src + '\" />');\n        });\n    });\n}\n\nmodule.exports = svgToImg;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/editHTMLElement.js":"var Promise = require('../../utils/promise');\n\n/**\n    Edit all elements matching a selector\n*/\nfunction editHTMLElement($, selector, fn) {\n    var $elements = $(selector);\n\n    return Promise.forEach($elements, function(el) {\n        var $el = $(el);\n        return fn($el);\n    });\n}\n\nmodule.exports = editHTMLElement;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/svgToPng.js":"var crc = require('crc');\nvar path = require('path');\n\nvar imagesUtil = require('../../utils/images');\nvar fs = require('../../utils/fs');\nvar LocationUtils = require('../../utils/location');\n\nvar editHTMLElement = require('./editHTMLElement');\n\n/**\n    Convert all SVG images to PNG\n\n    @param {String} rootFolder\n    @param {HTMLDom} $\n    @return {Promise}\n*/\nfunction svgToPng(rootFolder, currentFile, $) {\n    var currentDirectory = path.dirname(currentFile);\n\n    return editHTMLElement($, 'img', function($img) {\n        var src = $img.attr('src');\n        if (path.extname(src) !== '.svg') {\n            return;\n        }\n\n        // Calcul absolute path for this\n        src = LocationUtils.toAbsolute(src, currentDirectory, '.');\n\n        // We avoid generating twice the same PNG\n        var hash = crc.crc32(src).toString(16);\n        var fileName = hash + '.png';\n\n        // Input file path\n        var inputPath = path.join(rootFolder, src);\n\n        // Result file path\n        var filePath = path.join(rootFolder, fileName);\n\n        return fs.assertFile(filePath, function() {\n            return imagesUtil.convertSVGToPNG(inputPath, filePath);\n        })\n        .then(function() {\n            // Convert filename to a relative filename\n            fileName = LocationUtils.relative(currentDirectory, fileName);\n\n            // Replace src\n            $img.attr('src', fileName);\n        });\n    });\n}\n\n\nmodule.exports = svgToPng;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/images.js":"var Promise = require('./promise');\nvar command = require('./command');\nvar fs = require('./fs');\nvar error = require('./error');\n\n// Convert a svg file to a pmg\nfunction convertSVGToPNG(source, dest, options) {\n    if (!fs.existsSync(source)) return Promise.reject(new error.FileNotFoundError({ filename: source }));\n\n    return command.spawn('svgexport', [source, dest])\n    .fail(function(err) {\n        if (err.code == 'ENOENT') {\n            err = error.RequireInstallError({\n                cmd: 'svgexport',\n                install: 'Install it using: \"npm install svgexport -g\"'\n            });\n        }\n        throw err;\n    })\n    .then(function() {\n        if (fs.existsSync(dest)) return;\n\n        throw new Error('Error converting '+source+' into '+dest);\n    });\n}\n\n// Convert a svg buffer to a png file\nfunction convertSVGBufferToPNG(buf, dest) {\n    // Create a temporary SVG file to convert\n    return fs.tmpFile({\n        postfix: '.svg'\n    })\n    .then(function(tmpSvg) {\n        return fs.writeFile(tmpSvg, buf)\n        .then(function() {\n            return convertSVGToPNG(tmpSvg, dest);\n        });\n    });\n}\n\n// Converts a inline data: to png file\nfunction convertInlinePNG(source, dest) {\n    if (!/^data\\:image\\/png/.test(source)) return Promise.reject(new Error('Source is not a PNG data-uri'));\n\n    var base64data = source.split('data:image/png;base64,')[1];\n    var buf = new Buffer(base64data, 'base64');\n\n    return fs.writeFile(dest, buf)\n    .then(function() {\n        if (fs.existsSync(dest)) return;\n\n        throw new Error('Error converting '+source+' into '+dest);\n    });\n}\n\nmodule.exports = {\n    convertSVGToPNG: convertSVGToPNG,\n    convertSVGBufferToPNG: convertSVGBufferToPNG,\n    convertInlinePNG: convertInlinePNG\n};","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/command.js":"var is = require('is');\nvar childProcess = require('child_process');\nvar spawn = require('spawn-cmd').spawn;\nvar Promise = require('./promise');\n\n/**\n    Execute a command\n\n    @param {String} command\n    @param {Object} options\n    @return {Promise}\n*/\nfunction exec(command, options) {\n    var d = Promise.defer();\n\n    var child = childProcess.exec(command, options, function(err, stdout, stderr) {\n        if (!err) {\n            return d.resolve();\n        }\n\n        err.message = stdout.toString('utf8') + stderr.toString('utf8');\n        d.reject(err);\n    });\n\n    child.stdout.on('data', function (data) {\n        d.notify(data);\n    });\n\n    child.stderr.on('data', function (data) {\n        d.notify(data);\n    });\n\n    return d.promise;\n}\n\n/**\n    Spawn an executable\n\n    @param {String} command\n    @param {Array} args\n    @param {Object} options\n    @return {Promise}\n*/\nfunction spawnCmd(command, args, options) {\n    var d = Promise.defer();\n    var child = spawn(command, args, options);\n\n    child.on('error', function(error) {\n        return d.reject(error);\n    });\n\n    child.stdout.on('data', function (data) {\n        d.notify(data);\n    });\n\n    child.stderr.on('data', function (data) {\n        d.notify(data);\n    });\n\n    child.on('close', function(code) {\n        if (code === 0) {\n            d.resolve();\n        } else {\n            d.reject(new Error('Error with command \"'+command+'\"'));\n        }\n    });\n\n    return d.promise;\n}\n\n/**\n    Transform an option object to a command line string\n\n    @param {String|number} value\n    @param {String}\n*/\nfunction escapeShellArg(value) {\n    if (is.number(value)) {\n        return value;\n    }\n\n    value = String(value);\n    value = value.replace(/\"/g, '\\\\\"');\n\n    return '\"' + value + '\"';\n}\n\n/**\n    Transform a map of options into a command line arguments string\n\n    @param {Object} options\n    @return {String}\n*/\nfunction optionsToShellArgs(options) {\n    var result = [];\n\n    for (var key in options) {\n        var value = options[key];\n\n        if (value === null || value === undefined || value === false) {\n            continue;\n        }\n\n        if (is.bool(value)) {\n            result.push(key);\n        } else {\n            result.push(key + '=' + escapeShellArg(value));\n        }\n    }\n\n    return result.join(' ');\n}\n\nmodule.exports = {\n    exec: exec,\n    spawn: spawnCmd,\n    optionsToShellArgs: optionsToShellArgs\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/inlinePng.js":"var crc = require('crc');\nvar path = require('path');\n\nvar imagesUtil = require('../../utils/images');\nvar fs = require('../../utils/fs');\nvar LocationUtils = require('../../utils/location');\n\nvar editHTMLElement = require('./editHTMLElement');\n\n/**\n    Convert all inline PNG images to PNG file\n\n    @param {String} rootFolder\n    @param {HTMLDom} $\n    @return {Promise}\n*/\nfunction inlinePng(rootFolder, currentFile, $) {\n    var currentDirectory = path.dirname(currentFile);\n\n    return editHTMLElement($, 'img', function($img) {\n        var src = $img.attr('src');\n        if (!LocationUtils.isDataURI(src)) {\n            return;\n        }\n\n        // We avoid generating twice the same PNG\n        var hash = crc.crc32(src).toString(16);\n        var fileName = hash + '.png';\n\n        // Result file path\n        var filePath = path.join(rootFolder, fileName);\n\n        return fs.assertFile(filePath, function() {\n            return imagesUtil.convertInlinePNG(src, filePath);\n        })\n        .then(function() {\n            // Convert filename to a relative filename\n            fileName = LocationUtils.relative(currentDirectory, fileName);\n\n            // Replace src\n            $img.attr('src', fileName);\n        });\n    });\n}\n\n\nmodule.exports = inlinePng;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/resolveImages.js":"var path = require('path');\n\nvar LocationUtils = require('../../utils/location');\nvar editHTMLElement = require('./editHTMLElement');\n\n/**\n    Resolve all HTML images:\n        - /test.png in hello -> ../test.html\n\n    @param {String} currentFile\n    @param {HTMLDom} $\n*/\nfunction resolveImages(currentFile, $) {\n    var currentDirectory = path.dirname(currentFile);\n\n    return editHTMLElement($, 'img', function($img) {\n        var src = $img.attr('src');\n\n        if (LocationUtils.isExternal(src) || LocationUtils.isDataURI(src)) {\n            return;\n        }\n\n        // Calcul absolute path for this\n        src = LocationUtils.toAbsolute(src, currentDirectory, '.');\n\n        // Convert back to relative\n        src = LocationUtils.relative(currentDirectory, src);\n\n        $img.attr('src', src);\n    });\n}\n\nmodule.exports = resolveImages;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/fetchRemoteImages.js":"var path = require('path');\nvar crc = require('crc');\n\nvar editHTMLElement = require('./editHTMLElement');\nvar fs = require('../../utils/fs');\nvar LocationUtils = require('../../utils/location');\n\n/**\n    Fetch all remote images\n\n    @param {String} rootFolder\n    @param {String} currentFile\n    @param {HTMLDom} $\n    @return {Promise}\n*/\nfunction fetchRemoteImages(rootFolder, currentFile, $) {\n    var currentDirectory = path.dirname(currentFile);\n\n    return editHTMLElement($, 'img', function($img) {\n        var src = $img.attr('src');\n        var extension = path.extname(src);\n\n        if (!LocationUtils.isExternal(src)) {\n            return;\n        }\n\n        // We avoid generating twice the same PNG\n        var hash = crc.crc32(src).toString(16);\n        var fileName = hash + extension;\n        var filePath = path.join(rootFolder, fileName);\n\n        return fs.assertFile(filePath, function() {\n            return fs.download(src, filePath);\n        })\n        .then(function() {\n            // Convert to relative\n            src = LocationUtils.relative(currentDirectory, fileName);\n\n            $img.replaceWith('<img src=\"' + src + '\" />');\n        });\n    });\n}\n\nmodule.exports = fetchRemoteImages;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/addHeadingId.js":"var slug = require('github-slugid');\nvar editHTMLElement = require('./editHTMLElement');\n\n/**\n    Add ID to an heading\n\n    @param {HTMLElement} heading\n*/\nfunction addId(heading) {\n    if (heading.attr('id')) return;\n    heading.attr('id', slug(heading.text()));\n}\n\n/**\n    Add ID to all headings\n\n    @param {HTMLDom} $\n*/\nfunction addHeadingId($) {\n    return editHTMLElement($, 'h1,h2,h3,h4,h5,h6', addId);\n}\n\nmodule.exports = addHeadingId;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/resolveLinks.js":"var path = require('path');\nvar url = require('url');\n\nvar LocationUtils = require('../../utils/location');\nvar editHTMLElement = require('./editHTMLElement');\n\n/**\n    Resolve all HTML links:\n        - /test.md in hello -> ../test.html\n\n    @param {String} currentFile\n    @param {Function(String) -> String} resolveFile\n    @param {HTMLDom} $\n*/\nfunction resolveLinks(currentFile, resolveFile, $) {\n    var currentDirectory = path.dirname(currentFile);\n\n    return editHTMLElement($, 'a', function($a) {\n        var href = $a.attr('href');\n\n        // Don't change a tag without href\n        if (!href) {\n            return;\n        }\n\n        if (LocationUtils.isExternal(href)) {\n            $a.attr('target', '_blank');\n            return;\n        }\n\n        // Split anchor\n        var parsed = url.parse(href);\n        href = parsed.pathname || '';\n\n        if (href) {\n            // Calcul absolute path for this\n            href = LocationUtils.toAbsolute(href, currentDirectory, '.');\n\n            // Resolve file\n            href = resolveFile(href);\n\n            // Convert back to relative\n            href = LocationUtils.relative(currentDirectory, href);\n        }\n\n        // Add back anchor\n        href = href + (parsed.hash || '');\n\n        $a.attr('href', href);\n    });\n}\n\nmodule.exports = resolveLinks;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/annotateText.js":"var escape = require('escape-html');\n\n// Selector to ignore\nvar ANNOTATION_IGNORE = '.no-glossary,code,pre,a,script,h1,h2,h3,h4,h5,h6';\n\nfunction pregQuote( str ) {\n    return (str+'').replace(/([\\\\\\.\\+\\*\\?\\[\\^\\]\\$\\(\\)\\{\\}\\=\\!\\<\\>\\|\\:])/g, '\\\\$1');\n}\n\nfunction replaceText($, el, search, replace, text_only ) {\n    return $(el).each(function(){\n        var node = this.firstChild,\n            val,\n            new_val,\n\n            // Elements to be removed at the end.\n            remove = [];\n\n        // Only continue if firstChild exists.\n        if ( node ) {\n\n            // Loop over all childNodes.\n            while (node) {\n\n                // Only process text nodes.\n                if ( node.nodeType === 3 ) {\n\n                    // The original node value.\n                    val = node.nodeValue;\n\n                    // The new value.\n                    new_val = val.replace( search, replace );\n\n                    // Only replace text if the new value is actually different!\n                    if ( new_val !== val ) {\n\n                        if ( !text_only && /</.test( new_val ) ) {\n                            // The new value contains HTML, set it in a slower but far more\n                            // robust way.\n                            $(node).before( new_val );\n\n                            // Don't remove the node yet, or the loop will lose its place.\n                            remove.push( node );\n                        } else {\n                            // The new value contains no HTML, so it can be set in this\n                            // very fast, simple way.\n                            node.nodeValue = new_val;\n                        }\n                    }\n                }\n\n                node = node.nextSibling;\n            }\n        }\n\n        // Time to remove those elements!\n        if (remove.length) $(remove).remove();\n    });\n}\n\n/**\n * Annotate text using a list of GlossaryEntry\n *\n * @param {List<GlossaryEntry>}\n * @param {String} glossaryFilePath\n * @param {HTMLDom} $\n */\nfunction annotateText(entries, glossaryFilePath, $) {\n    entries.forEach(function(entry) {\n        var entryId     = entry.getID();\n        var name        = entry.getName();\n        var description = entry.getDescription();\n        var searchRegex = new RegExp( '\\\\b(' + pregQuote(name.toLowerCase()) + ')\\\\b' , 'gi' );\n\n        $('*').each(function() {\n            var $this = $(this);\n\n            if (\n                $this.is(ANNOTATION_IGNORE) ||\n                $this.parents(ANNOTATION_IGNORE).length > 0\n            ) return;\n\n            replaceText($, this, searchRegex, function(match) {\n                return '<a href=\"/' + glossaryFilePath + '#' + entryId + '\" '\n                    + 'class=\"glossary-term\" title=\"' + escape(description) + '\">'\n                    + match\n                    + '</a>';\n            });\n        });\n\n    });\n}\n\nmodule.exports = annotateText;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/modifiers/highlightCode.js":"var is = require('is');\nvar Immutable = require('immutable');\n\nvar Promise = require('../../utils/promise');\nvar editHTMLElement = require('./editHTMLElement');\n\n/**\n    Return language for a code blocks from a list of class names\n\n    @param {Array<String>}\n    @return {String}\n*/\nfunction getLanguageForClass(classNames) {\n    return Immutable.List(classNames)\n        .map(function(cl) {\n            // Markdown\n            if (cl.search('lang-') === 0) {\n                return cl.slice('lang-'.length);\n            }\n\n            // Asciidoc\n            if (cl.search('language-') === 0) {\n                return cl.slice('language-'.length);\n            }\n\n            return null;\n        })\n        .find(function(cl) {\n            return Boolean(cl);\n        });\n}\n\n\n/**\n    Highlight all code elements\n\n    @param {Function(lang, body) -> String} highlight\n    @param {HTMLDom} $\n    @return {Promise}\n*/\nfunction highlightCode(highlight, $) {\n    return editHTMLElement($, 'code', function($code) {\n        var classNames = ($code.attr('class') || '').split(' ');\n        var lang = getLanguageForClass(classNames);\n        var source = $code.text();\n\n        return Promise(highlight(lang, source))\n        .then(function(r) {\n            if (is.string(r.html)) {\n                $code.html(r.html);\n            } else {\n                $code.text(r.text);\n            }\n        });\n    });\n}\n\nmodule.exports = highlightCode;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/helper/writeFile.js":"var path = require('path');\nvar fs = require('../../utils/fs');\n\n/**\n    Write a file to the output folder\n\n    @param {Output} output\n    @param {String} filePath\n    @param {Buffer|String} content\n    @return {Promise}\n*/\nfunction writeFile(output, filePath, content) {\n    var rootFolder = output.getRoot();\n    filePath = path.join(rootFolder, filePath);\n\n    return fs.ensureFile(filePath)\n    .then(function() {\n        return fs.writeFile(filePath, content);\n    })\n    .thenResolve(output);\n}\n\nmodule.exports = writeFile;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/getModifiers.js":"var Modifiers = require('./modifiers');\nvar resolveFileToURL = require('./helper/resolveFileToURL');\nvar Api = require('../api');\nvar Plugins = require('../plugins');\nvar Promise = require('../utils/promise');\nvar defaultBlocks = require('../constants/defaultBlocks');\nvar fileToOutput = require('./helper/fileToOutput');\n\nvar CODEBLOCK = 'code';\n\n/**\n * Return default modifier to prepare a page for\n * rendering.\n *\n * @return {Array<Modifier>}\n */\nfunction getModifiers(output, page) {\n    var book = output.getBook();\n    var plugins = output.getPlugins();\n    var glossary = book.getGlossary();\n    var file = page.getFile();\n\n    // Glossary entries\n    var entries = glossary.getEntries();\n    var glossaryFile = glossary.getFile();\n    var glossaryFilename = fileToOutput(output, glossaryFile.getPath());\n\n    // Current file path\n    var currentFilePath = file.getPath();\n\n    // Get TemplateBlock for highlighting\n    var blocks = Plugins.listBlocks(plugins);\n    var code = blocks.get(CODEBLOCK) || defaultBlocks.get(CODEBLOCK);\n\n    // Current context\n    var context = Api.encodeGlobal(output);\n\n    return [\n        // Normalize IDs on headings\n        Modifiers.addHeadingId,\n\n        // Annotate text with glossary entries\n        Modifiers.annotateText.bind(null, entries, glossaryFilename),\n\n        // Resolve images\n        Modifiers.resolveImages.bind(null, currentFilePath),\n\n        // Resolve links (.md -> .html)\n        Modifiers.resolveLinks.bind(null,\n            currentFilePath,\n            resolveFileToURL.bind(null, output)\n        ),\n\n        // Highlight code blocks using \"code\" block\n        Modifiers.highlightCode.bind(null, function(lang, source) {\n            return Promise(code.applyBlock({\n                body: source,\n                kwargs: {\n                    language: lang\n                }\n            }, context))\n            .then(function(result) {\n                if (result.html === false) {\n                    return { text: result.body };\n                } else {\n                    return { html: result.body };\n                }\n            });\n        })\n    ];\n}\n\nmodule.exports = getModifiers;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/helper/resolveFileToURL.js":"var LocationUtils = require('../../utils/location');\n\nvar fileToURL = require('./fileToURL');\n\n/**\n * Resolve an absolute path (extracted from a link)\n *\n * @param {Output} output\n * @param {String} filePath\n * @return {String}\n */\nfunction resolveFileToURL(output, filePath) {\n    // Convert /test.png -> test.png\n    filePath = LocationUtils.toAbsolute(filePath, '', '');\n\n    var page = output.getPage(filePath);\n\n    // if file is a page, return correct .html url\n    if (page) {\n        filePath = fileToURL(output, filePath);\n    }\n\n    return LocationUtils.normalize(filePath);\n}\n\nmodule.exports = resolveFileToURL;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/helper/fileToURL.js":"var path = require('path');\nvar LocationUtils = require('../../utils/location');\n\nvar fileToOutput = require('./fileToOutput');\n\n/**\n    Convert a filePath (absolute) to an url (without hostname).\n    It returns an absolute path.\n\n    \"README.md\" -> \"/\"\n    \"test/hello.md\" -> \"test/hello.html\"\n    \"test/README.md\" -> \"test/\"\n\n    @param {Output} output\n    @param {String} filePath\n    @return {String}\n*/\nfunction fileToURL(output, filePath) {\n    var options = output.getOptions();\n    var directoryIndex = options.get('directoryIndex');\n\n    filePath = fileToOutput(output, filePath);\n\n    if (directoryIndex && path.basename(filePath) == 'index.html') {\n        filePath = path.dirname(filePath) + '/';\n    }\n\n    return LocationUtils.normalize(filePath);\n}\n\nmodule.exports = fileToURL;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/helper/fileToOutput.js":"var path = require('path');\n\nvar PathUtils = require('../../utils/path');\nvar LocationUtils = require('../../utils/location');\n\nvar OUTPUT_EXTENSION = '.html';\n\n/**\n * Convert a filePath (absolute) to a filename for output\n *\n * @param {Output} output\n * @param {String} filePath\n * @return {String}\n */\nfunction fileToOutput(output, filePath) {\n    var book = output.getBook();\n    var readme = book.getReadme();\n    var fileReadme = readme.getFile();\n\n    if (\n        path.basename(filePath, path.extname(filePath)) == 'README' ||\n        (fileReadme.exists() && filePath == fileReadme.getPath())\n    ) {\n        filePath = path.join(path.dirname(filePath), 'index' + OUTPUT_EXTENSION);\n    } else {\n        filePath = PathUtils.setExtension(filePath, OUTPUT_EXTENSION);\n    }\n\n    return LocationUtils.normalize(filePath);\n}\n\nmodule.exports = fileToOutput;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/api/index.js":"\nmodule.exports = {\n    encodePage:         require('./encodePage'),\n    decodePage:         require('./decodePage'),\n\n    encodeGlobal:       require('./encodeGlobal'),\n    decodeGlobal:       require('./decodeGlobal')\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/api/encodePage.js":"var JSONUtils = require('../json');\nvar deprecate = require('./deprecate');\nvar encodeProgress = require('./encodeProgress');\n\n/**\n    Encode a page in a context to a JS API\n\n    @param {Output} output\n    @param {Page} page\n    @return {Object}\n*/\nfunction encodePage(output, page) {\n    var book = output.getBook();\n    var summary = book.getSummary();\n    var fs = book.getContentFS();\n    var file = page.getFile();\n\n    // JS Page is based on the JSON output\n    var result = JSONUtils.encodePage(page, summary);\n\n    result.type = file.getType();\n    result.path = file.getPath();\n    result.rawPath = fs.resolve(result.path);\n\n    deprecate.field(output, 'page.progress', result, 'progress', function() {\n        return encodeProgress(output, page);\n    }, '\"page.progress\" property is deprecated');\n\n    deprecate.field(output, 'page.sections', result, 'sections', [\n        {\n            content: result.content,\n            type: 'normal'\n        }\n    ], '\"sections\" property is deprecated, use page.content instead');\n\n    return result;\n}\n\nmodule.exports = encodePage;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/api/deprecate.js":"var is = require('is');\nvar objectPath = require('object-path');\n\nvar logged = {};\nvar disabled = {};\n\n/**\n    Log a deprecated notice\n\n    @param {Book|Output} book\n    @param {String} key\n    @param {String} message\n*/\nfunction logNotice(book, key, message) {\n    if (logged[key] || disabled[key]) return;\n\n    logged[key] = true;\n\n    var logger = book.getLogger();\n    logger.warn.ln(message);\n}\n\n/**\n    Deprecate a function\n\n    @param {Book|Output} book\n    @param {String} key: unique identitifer for the deprecated\n    @param {Function} fn\n    @param {String} msg: message to print when called\n    @return {Function}\n*/\nfunction deprecateMethod(book, key, fn, msg) {\n    return function() {\n        logNotice(book, key, msg);\n\n        return fn.apply(this, arguments);\n    };\n}\n\n/**\n    Deprecate a property of an object\n\n    @param {Book|Output} book\n    @param {String} key: unique identitifer for the deprecated\n    @param {Object} instance\n    @param {String|Function} property\n    @param {String} msg: message to print when called\n    @return {Function}\n*/\nfunction deprecateField(book, key, instance, property, value, msg) {\n    var store = undefined;\n\n    var prepare = function() {\n        if (!is.undefined(store)) return;\n\n        if (is.fn(value)) store = value();\n        else store = value;\n    };\n\n    var getter = function(){\n        prepare();\n\n        logNotice(book, key, msg);\n        return store;\n    };\n    var setter = function(v) {\n        prepare();\n\n        logNotice(book, key, msg);\n        store = v;\n        return store;\n    };\n\n    Object.defineProperty(instance, property, {\n        get: getter,\n        set: setter,\n        enumerable: true,\n        configurable: true\n    });\n}\n\n/**\n    Enable a deprecation\n\n    @param {String} key: unique identitifer\n*/\nfunction enableDeprecation(key) {\n    disabled[key] = false;\n}\n\n/**\n    Disable a deprecation\n\n    @param {String} key: unique identitifer\n*/\nfunction disableDeprecation(key) {\n    disabled[key] = true;\n}\n\n/**\n    Deprecate a method in favor of another one\n\n    @param {Book} book\n    @param {String} key\n    @param {Object} instance\n    @param {String} oldName\n    @param {String} newName\n*/\nfunction deprecateRenamedMethod(book, key, instance, oldName, newName, msg) {\n    msg = msg || ('\"' + oldName + '\" is deprecated, use \"' + newName + '()\" instead');\n    var fn = objectPath.get(instance, newName);\n\n    instance[oldName] = deprecateMethod(book, key, fn, msg);\n}\n\nmodule.exports = {\n    method: deprecateMethod,\n    renamedMethod: deprecateRenamedMethod,\n    field: deprecateField,\n    enable: enableDeprecation,\n    disable: disableDeprecation\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/api/encodeProgress.js":"var Immutable = require('immutable');\nvar encodeNavigation = require('./encodeNavigation');\n\n/**\n    page.progress is a deprecated property from GitBook v2\n\n    @param {Output}\n    @param {Page}\n    @return {Object}\n*/\nfunction encodeProgress(output, page) {\n    var current = page.getPath();\n    var navigation = encodeNavigation(output);\n    navigation = Immutable.Map(navigation);\n\n    var n = navigation.size;\n    var percent = 0, prevPercent = 0, currentChapter = null;\n    var done = true;\n\n    var chapters = navigation\n        .map(function(nav, chapterPath) {\n            nav.path = chapterPath;\n            return nav;\n        })\n        .valueSeq()\n        .sortBy(function(nav) {\n            return nav.index;\n        })\n        .map(function(nav, i) {\n            // Calcul percent\n            nav.percent = (i * 100) / Math.max((n - 1), 1);\n\n            // Is it done\n            nav.done = done;\n            if (nav.path == current) {\n                currentChapter = nav;\n                percent = nav.percent;\n                done = false;\n            } else if (done) {\n                prevPercent = nav.percent;\n            }\n\n            return nav;\n        })\n        .toJS();\n\n    return {\n        // Previous percent\n        prevPercent: prevPercent,\n\n        // Current percent\n        percent: percent,\n\n        // List of chapter with progress\n        chapters: chapters,\n\n        // Current chapter\n        current: currentChapter\n    };\n}\n\nmodule.exports = encodeProgress;\n\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/api/encodeNavigation.js":"var Immutable = require('immutable');\n\n/**\n    Encode an article for next/prev\n\n    @param {Map<String:Page>}\n    @param {Article}\n    @return {Object}\n*/\nfunction encodeArticle(pages, article) {\n    var articlePath = article.getPath();\n\n    return {\n        path: articlePath,\n        title: article.getTitle(),\n        level: article.getLevel(),\n        exists: (articlePath && pages.has(articlePath)),\n        external: article.isExternal()\n    };\n}\n\n/**\n    this.navigation is a deprecated property from GitBook v2\n\n    @param {Output}\n    @return {Object}\n*/\nfunction encodeNavigation(output) {\n    var book = output.getBook();\n    var pages = output.getPages();\n    var summary = book.getSummary();\n    var articles = summary.getArticlesAsList();\n\n\n    var navigation = articles\n        .map(function(article, i) {\n            var ref = article.getRef();\n            if (!ref) {\n                return undefined;\n            }\n\n            var prev = articles.get(i - 1);\n            var next = articles.get(i + 1);\n\n            return [\n                ref,\n                {\n                    index: i,\n                    title: article.getTitle(),\n                    introduction: (i === 0),\n                    prev: prev? encodeArticle(pages, prev) : undefined,\n                    next: next? encodeArticle(pages, next) : undefined,\n                    level: article.getLevel()\n                }\n            ];\n        })\n        .filter(function(e) {\n            return Boolean(e);\n        });\n\n    return Immutable.Map(navigation).toJS();\n}\n\nmodule.exports = encodeNavigation;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/api/decodePage.js":"var deprecate = require('./deprecate');\n\n/**\n    Decode changes from a JS API to a page object.\n    Only the content can be edited by plugin's hooks.\n\n    @param {Output} output\n    @param {Page} page: page instance to edit\n    @param {Object} result: result from API\n    @return {Page}\n*/\nfunction decodePage(output, page, result) {\n    var originalContent = page.getContent();\n\n    // No returned value\n    // Existing content will be used\n    if (!result) {\n        return page;\n    }\n\n    deprecate.disable('page.sections');\n\n    // GitBook 3\n    // Use returned page.content if different from original content\n    if (result.content != originalContent) {\n        page = page.set('content', result.content);\n    }\n\n    // GitBook 2 compatibility\n    // Finally, use page.sections\n    else if (result.sections) {\n        page = page.set('content',\n            result.sections.map(function(section) {\n                return section.content;\n            }).join('\\n')\n        );\n    }\n\n    deprecate.enable('page.sections');\n\n    return page;\n}\n\nmodule.exports = decodePage;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/api/encodeGlobal.js":"var path = require('path');\nvar Promise = require('../utils/promise');\nvar PathUtils = require('../utils/path');\nvar fs = require('../utils/fs');\n\nvar Plugins = require('../plugins');\nvar deprecate = require('./deprecate');\nvar fileToURL = require('../output/helper/fileToURL');\nvar defaultBlocks = require('../constants/defaultBlocks');\nvar gitbook = require('../gitbook');\nvar parsers = require('../parsers');\n\nvar encodeConfig = require('./encodeConfig');\nvar encodeSummary = require('./encodeSummary');\nvar encodeNavigation = require('./encodeNavigation');\nvar encodePage = require('./encodePage');\n\n/**\n    Encode a global context into a JS object\n    It's the context for page's hook, etc\n\n    @param {Output} output\n    @return {Object}\n*/\nfunction encodeGlobal(output) {\n    var book = output.getBook();\n    var bookFS = book.getContentFS();\n    var logger = output.getLogger();\n    var outputFolder = output.getRoot();\n    var plugins = output.getPlugins();\n    var blocks = Plugins.listBlocks(plugins);\n\n    var result = {\n        log: logger,\n        config: encodeConfig(output, book.getConfig()),\n        summary: encodeSummary(output, book.getSummary()),\n\n        /**\n            Check if the book is a multilingual book\n\n            @return {Boolean}\n        */\n        isMultilingual: function() {\n            return book.isMultilingual();\n        },\n\n        /**\n            Check if the book is a language book for a multilingual book\n\n            @return {Boolean}\n        */\n        isLanguageBook: function() {\n            return book.isLanguageBook();\n        },\n\n        /**\n            Read a file from the book\n\n            @param {String} fileName\n            @return {Promise<Buffer>}\n        */\n        readFile: function(fileName) {\n            return bookFS.read(fileName);\n        },\n\n        /**\n            Read a file from the book as a string\n\n            @param {String} fileName\n            @return {Promise<String>}\n        */\n        readFileAsString: function(fileName) {\n            return bookFS.readAsString(fileName);\n        },\n\n        /**\n            Resolve a file from the book root\n\n            @param {String} fileName\n            @return {String}\n        */\n        resolve: function(fileName) {\n            return path.resolve(book.getContentRoot(), fileName);\n        },\n\n        /**\n            Resolve a page by it path\n\n            @param {String} filePath\n            @return {String}\n        */\n        getPageByPath: function(filePath) {\n            var page = output.getPage(filePath);\n            if (!page) return undefined;\n\n            return encodePage(output, page);\n        },\n\n        /**\n            Render a block of text (markdown/asciidoc)\n\n            @param {String} type\n            @param {String} text\n            @return {Promise<String>}\n        */\n        renderBlock: function(type, text) {\n            var parser = parsers.get(type);\n\n            return parser.parsePage(text)\n                .get('content');\n        },\n\n        /**\n            Render an inline text (markdown/asciidoc)\n\n            @param {String} type\n            @param {String} text\n            @return {Promise<String>}\n        */\n        renderInline: function(type, text) {\n            var parser = parsers.get(type);\n\n            return parser.parseInline(text)\n                .get('content');\n        },\n\n        template: {\n            /**\n                Apply a templating block and returns its result\n\n                @param {String} name\n                @param {Object} blockData\n                @return {Promise|Object}\n            */\n            applyBlock: function(name, blockData) {\n                var block = blocks.get(name) || defaultBlocks.get(name);\n                return Promise(block.applyBlock(blockData, result));\n            }\n        },\n\n        output: {\n            /**\n                Name of the generator being used\n                {String}\n            */\n            name: output.getGenerator(),\n\n            /**\n                Return absolute path to the root folder of output\n                @return {String}\n            */\n            root: function() {\n                return outputFolder;\n            },\n\n            /**\n                Resolve a file from the output root\n\n                @param {String} fileName\n                @return {String}\n            */\n            resolve: function(fileName) {\n                return path.resolve(outputFolder, fileName);\n            },\n\n            /**\n                Convert a filepath into an url\n                @return {String}\n            */\n            toURL: function(filePath) {\n                return fileToURL(output, filePath);\n            },\n\n            /**\n                Check that a file exists.\n\n                @param {String} fileName\n                @return {Promise}\n            */\n            hasFile: function(fileName, content) {\n                return Promise()\n                .then(function() {\n                    var filePath = PathUtils.resolveInRoot(outputFolder, fileName);\n\n                    return fs.exists(filePath);\n                });\n            },\n\n            /**\n                Write a file to the output folder,\n                It creates the required folder\n\n                @param {String} fileName\n                @param {Buffer} content\n                @return {Promise}\n            */\n            writeFile: function(fileName, content) {\n                return Promise()\n                .then(function() {\n                    var filePath = PathUtils.resolveInRoot(outputFolder, fileName);\n\n                    return fs.ensureFile(filePath)\n                    .then(function() {\n                        return fs.writeFile(filePath, content);\n                    });\n                });\n            },\n\n            /**\n                Copy a file to the output folder\n                It creates the required folder.\n\n                @param {String} inputFile\n                @param {String} outputFile\n                @param {Buffer} content\n                @return {Promise}\n            */\n            copyFile: function(inputFile, outputFile, content) {\n                return Promise()\n                .then(function() {\n                    var outputFilePath = PathUtils.resolveInRoot(outputFolder, outputFile);\n\n                    return fs.ensureFile(outputFilePath)\n                    .then(function() {\n                        return fs.copy(inputFile, outputFilePath);\n                    });\n                });\n            }\n        },\n\n        gitbook: {\n            version: gitbook.version\n        }\n    };\n\n    // Deprecated properties\n\n    deprecate.renamedMethod(output, 'this.isSubBook', result, 'isSubBook', 'isLanguageBook');\n    deprecate.renamedMethod(output, 'this.contentLink', result, 'contentLink', 'output.toURL');\n\n    deprecate.field(output, 'this.generator', result, 'generator',\n        output.getGenerator(), '\"this.generator\" property is deprecated, use \"this.output.name\" instead');\n\n    deprecate.field(output, 'this.navigation', result, 'navigation', function() {\n        return encodeNavigation(output);\n    }, '\"navigation\" property is deprecated');\n\n    deprecate.field(output, 'this.book', result, 'book',\n        result, '\"book\" property is deprecated, use \"this\" directly instead');\n\n    deprecate.field(output, 'this.options', result, 'options',\n        result.config.values, '\"options\" property is deprecated, use config.get(key) instead');\n\n    return result;\n}\n\nmodule.exports = encodeGlobal;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/index.js":"\nmodule.exports = {\n    loadForBook:            require('./loadForBook'),\n    validateConfig:         require('./validateConfig'),\n    installPlugins:         require('./installPlugins'),\n    listResources:          require('./listResources'),\n    listBlocks:             require('./listBlocks'),\n    listFilters:            require('./listFilters')\n};\n\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/loadForBook.js":"var Immutable = require('immutable');\n\nvar Promise = require('../utils/promise');\nvar listDepsForBook = require('./listDepsForBook');\nvar findForBook = require('./findForBook');\nvar loadPlugin = require('./loadPlugin');\n\n\n/**\n * Load all plugins in a book\n *\n * @param {Book}\n * @return {Promise<Map<String:Plugin>}\n */\nfunction loadForBook(book) {\n    var logger = book.getLogger();\n\n    // List the dependencies\n    var requirements = listDepsForBook(book);\n\n    // List all plugins installed in the book\n    return findForBook(book)\n    .then(function(installedMap) {\n        var missing = [];\n        var plugins = requirements.reduce(function(result, dep) {\n            var name = dep.getName();\n            var installed = installedMap.get(name);\n\n            if (installed) {\n                var deps = installedMap\n                    .filter(function(plugin) {\n                        return plugin.getParent() === name;\n                    })\n                    .toArray();\n\n                result = result.concat(deps);\n                result.push(installed);\n            } else {\n                missing.push(name);\n            }\n\n            return result;\n        }, []);\n\n        // Convert plugins list to a map\n        plugins = Immutable.List(plugins)\n            .map(function(plugin) {\n                return [\n                    plugin.getName(),\n                    plugin\n                ];\n            });\n        plugins = Immutable.OrderedMap(plugins);\n\n        // Log state\n        logger.info.ln(installedMap.size + ' plugins are installed');\n        if (requirements.size != installedMap.size) {\n            logger.info.ln(requirements.size + ' explicitly listed');\n        }\n\n        // Verify that all plugins are present\n        if (missing.length > 0) {\n            throw new Error('Couldn\\'t locate plugins \"' + missing.join(', ') + '\", Run \\'gitbook install\\' to install plugins from registry.');\n        }\n\n        return Promise.map(plugins, function(plugin) {\n            return loadPlugin(book, plugin);\n        });\n    });\n}\n\n\nmodule.exports = loadForBook;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/listDepsForBook.js":"var listDependencies = require('./listDependencies');\n\n/**\n * List all plugin requirements for a book.\n * It can be different from the final list of plugins,\n * since plugins can have their own dependencies\n *\n * @param {Book}\n * @return {List<PluginDependency>}\n */\nfunction listDepsForBook(book) {\n    var config = book.getConfig();\n    var plugins = config.getPluginDependencies();\n\n    return listDependencies(plugins);\n}\n\nmodule.exports = listDepsForBook;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/listDependencies.js":"var DEFAULT_PLUGINS = require('../constants/defaultPlugins');\nvar sortDependencies = require('./sortDependencies');\n\n/**\n * List all dependencies for a book, including default plugins.\n * It returns a concat with default plugins and remove disabled ones.\n *\n * @param {List<PluginDependency>} deps\n * @return {List<PluginDependency>}\n */\nfunction listDependencies(deps) {\n    // Extract list of plugins to disable (starting with -)\n    var toRemove = deps\n        .filter(function(plugin) {\n            return !plugin.isEnabled();\n        })\n        .map(function(plugin) {\n            return plugin.getName();\n        });\n\n    // Concat with default plugins\n    deps = deps.concat(DEFAULT_PLUGINS);\n\n    // Remove plugins\n    deps = deps.filterNot(function(plugin) {\n        return toRemove.includes(plugin.getName());\n    });\n\n    // Sort\n    return sortDependencies(deps);\n}\n\nmodule.exports = listDependencies;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/sortDependencies.js":"var Immutable = require('immutable');\n\nvar THEME_PREFIX = require('../constants/themePrefix');\n\nvar TYPE_PLUGIN = 'plugin';\nvar TYPE_THEME  = 'theme';\n\n\n/**\n * Returns the type of a plugin given its name\n * @param {Plugin} plugin\n * @return {String}\n */\nfunction pluginType(plugin) {\n    var name = plugin.getName();\n    return (name && name.indexOf(THEME_PREFIX) === 0) ? TYPE_THEME : TYPE_PLUGIN;\n}\n\n\n/**\n * Sort the list of dependencies to match list in book.json\n * The themes should always be loaded after the plugins\n *\n * @param {List<PluginDependency>} deps\n * @return {List<PluginDependency>}\n */\nfunction sortDependencies(plugins) {\n    var byTypes = plugins.groupBy(pluginType);\n\n    return byTypes.get(TYPE_PLUGIN, Immutable.List())\n        .concat(byTypes.get(TYPE_THEME, Immutable.List()));\n}\n\nmodule.exports = sortDependencies;","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/themePrefix.js":"/*\n    All GitBook themes plugins name start with this prefix once shorted.\n*/\nmodule.exports = 'theme-';","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/findForBook.js":"var Immutable = require('immutable');\n\nvar Promise = require('../utils/promise');\nvar timing = require('../utils/timing');\nvar findInstalled = require('./findInstalled');\nvar locateRootFolder = require('./locateRootFolder');\n\n/**\n * List all plugins installed in a book\n *\n * @param {Book}\n * @return {Promise<OrderedMap<String:Plugin>>}\n */\nfunction findForBook(book) {\n    return timing.measure(\n        'plugins.findForBook',\n\n        Promise.all([\n            findInstalled(locateRootFolder()),\n            findInstalled(book.getRoot())\n        ])\n\n        // Merge all plugins\n        .then(function(results) {\n            return Immutable.List(results)\n                .reduce(function(out, result) {\n                    return out.merge(result);\n                }, Immutable.OrderedMap());\n        })\n    );\n}\n\n\nmodule.exports = findForBook;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/findInstalled.js":"var readInstalled = require('read-installed');\nvar Immutable = require('immutable');\nvar path = require('path');\n\nvar Promise = require('../utils/promise');\nvar fs = require('../utils/fs');\nvar Plugin = require('../models/plugin');\nvar PREFIX = require('../constants/pluginPrefix');\n\n/**\n * Validate if a package name is a GitBook plugin\n *\n * @return {Boolean}\n */\nfunction validateId(name) {\n    return name && name.indexOf(PREFIX) === 0;\n}\n\n\n/**\n * List all packages installed inside a folder\n *\n * @param {String} folder\n * @return {OrderedMap<String:Plugin>}\n */\nfunction findInstalled(folder) {\n    var options = {\n        dev: false,\n        log: function() {},\n        depth: 4\n    };\n    var results = Immutable.OrderedMap();\n\n    function onPackage(pkg, parent) {\n        if (!pkg.name) return;\n\n        var name = pkg.name;\n        var version = pkg.version;\n        var pkgPath = pkg.realPath;\n        var depth = pkg.depth;\n        var dependencies = pkg.dependencies;\n\n        var pluginName = name.slice(PREFIX.length);\n\n        if (!validateId(name)){\n            if (parent) return;\n        } else {\n            results = results.set(pluginName, Plugin({\n                name: pluginName,\n                version: version,\n                path: pkgPath,\n                depth: depth,\n                parent: parent\n            }));\n        }\n\n        Immutable.Map(dependencies).forEach(function(dep) {\n            onPackage(dep, pluginName);\n        });\n    }\n\n    // Search for gitbook-plugins in node_modules folder\n    var node_modules = path.join(folder, 'node_modules');\n\n    // List all folders in node_modules\n    return fs.readdir(node_modules)\n    .fail(function() {\n        return Promise([]);\n    })\n    .then(function(modules) {\n        return Promise.serie(modules, function(module) {\n            // Not a gitbook-plugin\n            if (!validateId(module)) {\n                return Promise();\n            }\n\n            // Read gitbook-plugin package details\n            var module_folder = path.join(node_modules, module);\n            return Promise.nfcall(readInstalled, module_folder, options)\n            .then(function(data) {\n                onPackage(data);\n            });\n        });\n    })\n    .then(function() {\n        // Return installed plugins\n        return results;\n    });\n}\n\nmodule.exports = findInstalled;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/plugin.js":"var Immutable = require('immutable');\n\nvar TemplateBlock = require('./templateBlock');\nvar PluginDependency = require('./pluginDependency');\nvar THEME_PREFIX = require('../constants/themePrefix');\n\nvar DEFAULT_VERSION = '*';\n\nvar Plugin = Immutable.Record({\n    name:       String(),\n\n    // Requirement version (ex: \">1.0.0\")\n    version:    String(DEFAULT_VERSION),\n\n    // Path to load this plugin\n    path:       String(),\n\n    // Depth of this plugin in the dependency tree\n    depth:      Number(0),\n\n    // Parent depending on this plugin\n    parent:     String(),\n\n    // Content of the \"package.json\"\n    package:    Immutable.Map(),\n\n    // Content of the package itself\n    content:    Immutable.Map()\n}, 'Plugin');\n\nPlugin.prototype.getName = function() {\n    return this.get('name');\n};\n\nPlugin.prototype.getPath = function() {\n    return this.get('path');\n};\n\nPlugin.prototype.getVersion = function() {\n    return this.get('version');\n};\n\nPlugin.prototype.getPackage = function() {\n    return this.get('package');\n};\n\nPlugin.prototype.getContent = function() {\n    return this.get('content');\n};\n\nPlugin.prototype.getDepth = function() {\n    return this.get('depth');\n};\n\nPlugin.prototype.getParent = function() {\n    return this.get('parent');\n};\n\n/**\n * Return the ID on NPM for this plugin\n * @return {String}\n */\nPlugin.prototype.getNpmID = function() {\n    return PluginDependency.nameToNpmID(this.getName());\n};\n\n/**\n * Check if a plugin is loaded\n * @return {Boolean}\n */\nPlugin.prototype.isLoaded = function() {\n    return Boolean(this.getPackage().size > 0);\n};\n\n/**\n * Check if a plugin is a theme given its name\n * @return {Boolean}\n */\nPlugin.prototype.isTheme = function() {\n    var name = this.getName();\n    return (name && name.indexOf(THEME_PREFIX) === 0);\n};\n\n/**\n * Return map of hooks\n * @return {Map<String:Function>}\n */\nPlugin.prototype.getHooks = function() {\n    return this.getContent().get('hooks') || Immutable.Map();\n};\n\n/**\n * Return infos about resources for a specific type\n * @param {String} type\n * @return {Map<String:Mixed>}\n */\nPlugin.prototype.getResources = function(type) {\n    if (type != 'website' && type != 'ebook') {\n        throw new Error('Invalid assets type ' + type);\n    }\n\n    var content = this.getContent();\n    return (content.get(type)\n        || (type == 'website'? content.get('book') : null)\n        || Immutable.Map());\n};\n\n/**\n * Return map of filters\n * @return {Map<String:Function>}\n */\nPlugin.prototype.getFilters = function() {\n    return this.getContent().get('filters');\n};\n\n/**\n * Return map of blocks\n * @return {Map<String:TemplateBlock>}\n */\nPlugin.prototype.getBlocks = function() {\n    var blocks = this.getContent().get('blocks');\n    blocks = blocks || Immutable.Map();\n\n    return blocks\n        .map(function(block, blockName) {\n            return TemplateBlock.create(blockName, block);\n        });\n};\n\n/**\n * Return a specific hook\n * @param {String} name\n * @return {Function|undefined}\n */\nPlugin.prototype.getHook = function(name) {\n    return this.getHooks().get(name);\n};\n\n/**\n * Create a plugin from a string\n * @param {String}\n * @return {Plugin}\n */\nPlugin.createFromString = function(s) {\n    var parts = s.split('@');\n    var name = parts[0];\n    var version = parts.slice(1).join('@');\n\n    return new Plugin({\n        name: name,\n        version: version || DEFAULT_VERSION\n    });\n};\n\n/**\n * Create a plugin from a dependency\n * @param {PluginDependency}\n * @return {Plugin}\n */\nPlugin.createFromDep = function(dep) {\n    return new Plugin({\n        name: dep.getName(),\n        version: dep.getVersion()\n    });\n};\n\nPlugin.nameToNpmID = PluginDependency.nameToNpmID;\n\nmodule.exports = Plugin;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/templateBlock.js":"var is = require('is');\nvar extend = require('extend');\nvar Immutable = require('immutable');\n\nvar Promise = require('../utils/promise');\nvar genKey = require('../utils/genKey');\nvar TemplateShortcut = require('./templateShortcut');\n\nvar NODE_ENDARGS = '%%endargs%%';\n\nvar TemplateBlock = Immutable.Record({\n    // Name of block, also the start tag\n    name:           String(),\n\n    // End tag, default to \"end<name>\"\n    end:            String(),\n\n    // Function to process the block content\n    process:        Function(),\n\n    // List of String, for inner block tags\n    blocks:         Immutable.List(),\n\n    // List of shortcuts to replace with this block\n    shortcuts:      Immutable.Map()\n}, 'TemplateBlock');\n\nTemplateBlock.prototype.getName = function() {\n    return this.get('name');\n};\n\nTemplateBlock.prototype.getEndTag = function() {\n    return this.get('end') || ('end' + this.getName());\n};\n\nTemplateBlock.prototype.getProcess = function() {\n    return this.get('process');\n};\n\nTemplateBlock.prototype.getBlocks = function() {\n    return this.get('blocks');\n};\n\n\n/**\n * Return shortcuts associated with this block or undefined\n * @return {TemplateShortcut|undefined}\n */\nTemplateBlock.prototype.getShortcuts = function() {\n    var shortcuts = this.get('shortcuts');\n    if (shortcuts.size === 0) {\n        return undefined;\n    }\n\n    return TemplateShortcut.createForBlock(this, shortcuts);\n};\n\n/**\n * Return name for the nunjucks extension\n * @return {String}\n */\nTemplateBlock.prototype.getExtensionName = function() {\n    return 'Block' + this.getName() + 'Extension';\n};\n\n/**\n * Return a nunjucks extension to represents this block\n * @return {Nunjucks.Extension}\n */\nTemplateBlock.prototype.toNunjucksExt = function(mainContext, blocksOutput) {\n    blocksOutput = blocksOutput || {};\n\n    var that = this;\n    var name = this.getName();\n    var endTag = this.getEndTag();\n    var blocks = this.getBlocks().toJS();\n\n    function Ext() {\n        this.tags = [name];\n\n        this.parse = function(parser, nodes) {\n            var lastBlockName = null;\n            var lastBlockArgs = null;\n            var allBlocks = blocks.concat([endTag]);\n\n            // Parse first block\n            var tok = parser.nextToken();\n            lastBlockArgs = parser.parseSignature(null, true);\n            parser.advanceAfterBlockEnd(tok.value);\n\n            var args = new nodes.NodeList();\n            var bodies = [];\n            var blockNamesNode = new nodes.Array(tok.lineno, tok.colno);\n            var blockArgCounts = new nodes.Array(tok.lineno, tok.colno);\n\n            // Parse while we found \"end<block>\"\n            do {\n                // Read body\n                var currentBody = parser.parseUntilBlocks.apply(parser, allBlocks);\n\n                // Handle body with previous block name and args\n                blockNamesNode.addChild(new nodes.Literal(args.lineno, args.colno, lastBlockName));\n                blockArgCounts.addChild(new nodes.Literal(args.lineno, args.colno, lastBlockArgs.children.length));\n                bodies.push(currentBody);\n\n                // Append arguments of this block as arguments of the run function\n                lastBlockArgs.children.forEach(function(child) {\n                    args.addChild(child);\n                });\n\n                // Read new block\n                lastBlockName = parser.nextToken().value;\n\n                // Parse signature and move to the end of the block\n                if (lastBlockName != endTag) {\n                    lastBlockArgs = parser.parseSignature(null, true);\n                }\n\n                parser.advanceAfterBlockEnd(lastBlockName);\n            } while (lastBlockName != endTag);\n\n            args.addChild(blockNamesNode);\n            args.addChild(blockArgCounts);\n            args.addChild(new nodes.Literal(args.lineno, args.colno, NODE_ENDARGS));\n\n            return new nodes.CallExtensionAsync(this, 'run', args, bodies);\n        };\n\n        this.run = function(context) {\n            var fnArgs = Array.prototype.slice.call(arguments, 1);\n\n            var args;\n            var blocks = [];\n            var bodies = [];\n            var blockNames;\n            var blockArgCounts;\n            var callback;\n\n            // Extract callback\n            callback = fnArgs.pop();\n\n            // Detect end of arguments\n            var endArgIndex = fnArgs.indexOf(NODE_ENDARGS);\n\n            // Extract arguments and bodies\n            args = fnArgs.slice(0, endArgIndex);\n            bodies = fnArgs.slice(endArgIndex + 1);\n\n            // Extract block counts\n            blockArgCounts = args.pop();\n            blockNames = args.pop();\n\n            // Recreate list of blocks\n            blockNames.forEach(function(name, i) {\n                var countArgs = blockArgCounts[i];\n                var blockBody = bodies.shift();\n\n                var blockArgs = countArgs > 0? args.slice(0, countArgs) : [];\n                args = args.slice(countArgs);\n                var blockKwargs = extractKwargs(blockArgs);\n\n                blocks.push({\n                    name: name,\n                    body: blockBody(),\n                    args: blockArgs,\n                    kwargs: blockKwargs\n                });\n            });\n\n            var mainBlock = blocks.shift();\n            mainBlock.blocks = blocks;\n\n            Promise()\n            .then(function() {\n                var ctx = extend({\n                    ctx: context\n                }, mainContext || {});\n\n                return that.applyBlock(mainBlock, ctx);\n            })\n            .then(function(result) {\n                return that.blockResultToHtml(result, blocksOutput);\n            })\n            .nodeify(callback);\n        };\n    }\n\n    return Ext;\n};\n\n/**\n * Apply a block to a content\n * @param {Object} inner\n * @param {Object} context\n * @return {Promise<String>|String}\n */\nTemplateBlock.prototype.applyBlock = function(inner, context) {\n    var processFn = this.getProcess();\n\n    inner = inner || {};\n    inner.args = inner.args || [];\n    inner.kwargs = inner.kwargs || {};\n    inner.blocks = inner.blocks || [];\n\n    var r = processFn.call(context, inner);\n\n    if (Promise.isPromiseAlike(r)) {\n        return r.then(this.normalizeBlockResult.bind(this));\n    } else {\n        return this.normalizeBlockResult(r);\n    }\n};\n\n/**\n * Normalize result from a block process function\n * @param {Object|String} result\n * @return {Object}\n */\nTemplateBlock.prototype.normalizeBlockResult = function(result) {\n    if (is.string(result)) {\n        result = { body: result };\n    }\n    result.name = this.getName();\n\n    return result;\n};\n\n/**\n * Convert a block result to HTML\n * @param {Object} result\n * @param {Object} blocksOutput: stored post processing blocks in this object\n * @return {String}\n */\nTemplateBlock.prototype.blockResultToHtml = function(result, blocksOutput) {\n    var indexedKey;\n    var toIndex = (!result.parse) || (result.post !== undefined);\n\n    if (toIndex) {\n        indexedKey = genKey();\n        blocksOutput[indexedKey] = result;\n    }\n\n    // Parsable block, just return it\n    if (result.parse) {\n        return result.body;\n    }\n\n    // Return it as a position marker\n    return '{{-%' + indexedKey + '%-}}';\n\n};\n\n/**\n * Create a template block from a function or an object\n * @param {String} blockName\n * @param {Object} block\n * @return {TemplateBlock}\n */\nTemplateBlock.create = function(blockName, block) {\n    if (is.fn(block)) {\n        block = new Immutable.Map({\n            process: block\n        });\n    }\n\n    block = new TemplateBlock(block);\n    block = block.set('name', blockName);\n    return block;\n};\n\n/**\n * Extract kwargs from an arguments array\n * @param {Array} args\n * @return {Object}\n */\nfunction extractKwargs(args) {\n    var last = args[args.length - 1];\n    return (is.object(last) && last.__keywords)? args.pop() : {};\n}\n\nmodule.exports = TemplateBlock;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/genKey.js":"var lastKey = 0;\n\n/*\n    Generate a random key\n    @return {String}\n*/\nfunction generateKey() {\n    lastKey += 1;\n    var str = lastKey.toString(16);\n    return '00000'.slice(str.length) + str;\n}\n\nmodule.exports = generateKey;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/templateShortcut.js":"var Immutable = require('immutable');\nvar is = require('is');\n\n/*\n    A TemplateShortcut is defined in plugin's template blocks\n    to replace content with a templating block using delimiters.\n*/\nvar TemplateShortcut = Immutable.Record({\n    // List of parser names accepting this shortcut\n    parsers:     Immutable.Map(),\n\n    start:       String(),\n    end:         String(),\n\n    startTag:    String(),\n    endTag:      String()\n}, 'TemplateShortcut');\n\nTemplateShortcut.prototype.getStart = function() {\n    return this.get('start');\n};\n\nTemplateShortcut.prototype.getEnd = function() {\n    return this.get('end');\n};\n\nTemplateShortcut.prototype.getStartTag = function() {\n    return this.get('startTag');\n};\n\nTemplateShortcut.prototype.getEndTag = function() {\n    return this.get('endTag');\n};\n\nTemplateShortcut.prototype.getParsers = function() {\n    return this.get('parsers');\n};\n\n/**\n    Test if this shortcut accept a parser\n\n    @param {Parser|String} parser\n    @return {Boolean}\n*/\nTemplateShortcut.prototype.acceptParser = function(parser) {\n    if (!is.string(parser)) {\n        parser = parser.getName();\n    }\n\n    var parserNames = this.get('parsers');\n    return parserNames.includes(parser);\n};\n\n/**\n    Create a shortcut for a block\n\n    @param {TemplateBlock} block\n    @param {Map} details\n    @return {TemplateShortcut}\n*/\nTemplateShortcut.createForBlock = function(block, details) {\n    details = Immutable.fromJS(details);\n\n    return new TemplateShortcut({\n        parsers:        details.get('parsers'),\n        start:          details.get('start'),\n        end:            details.get('end'),\n        startTag:       block.getName(),\n        endTag:         block.getEndTag()\n    });\n};\n\nmodule.exports = TemplateShortcut;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/locateRootFolder.js":"var path = require('path');\nvar resolve = require('resolve');\n\nvar DEFAULT_PLUGINS = require('../constants/defaultPlugins');\n\n/**\n * Resolve the root folder containing for node_modules\n * since gitbook can be used as a library and dependency can be flattened.\n *\n * @return {String} folderPath\n */\nfunction locateRootFolder() {\n    var firstDefaultPlugin = DEFAULT_PLUGINS.first();\n    var pluginPath = resolve.sync(firstDefaultPlugin.getNpmID() + '/package.json', {\n        basedir: __dirname\n    });\n    var nodeModules = path.resolve(pluginPath, '../../..');\n\n    return nodeModules;\n}\n\nmodule.exports = locateRootFolder;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/loadPlugin.js":"var path = require('path');\nvar resolve = require('resolve');\nvar Immutable = require('immutable');\n\nvar Promise = require('../utils/promise');\nvar error = require('../utils/error');\nvar timing = require('../utils/timing');\n\nvar validatePlugin = require('./validatePlugin');\n\n// Return true if an error is a \"module not found\"\n// Wait on https://github.com/substack/node-resolve/pull/81 to be merged\nfunction isModuleNotFound(err) {\n    return err.code == 'MODULE_NOT_FOUND' || err.message.indexOf('Cannot find module') >= 0;\n}\n\n/**\n    Load a plugin in a book\n\n    @param {Book} book\n    @param {Plugin} plugin\n    @param {String} pkgPath (optional)\n    @return {Promise<Plugin>}\n*/\nfunction loadPlugin(book, plugin) {\n    var logger = book.getLogger();\n\n    var name = plugin.getName();\n    var pkgPath = plugin.getPath();\n\n    // Try loading plugins from different location\n    var p = Promise()\n    .then(function() {\n        var packageContent;\n        var packageMain;\n        var content;\n\n        // Locate plugin and load package.json\n        try {\n            var res = resolve.sync('./package.json', { basedir: pkgPath });\n\n            pkgPath = path.dirname(res);\n            packageContent = require(res);\n        } catch (err) {\n            if (!isModuleNotFound(err)) throw err;\n\n            packageContent = undefined;\n            content = undefined;\n\n            return;\n        }\n\n        // Locate the main package\n        try {\n            var indexJs = path.normalize(packageContent.main || 'index.js');\n            packageMain = resolve.sync('./' + indexJs, { basedir: pkgPath });\n        } catch (err) {\n            if (!isModuleNotFound(err)) throw err;\n            packageMain = undefined;\n        }\n\n        // Load plugin JS content\n        if (packageMain) {\n            try {\n                content = require(packageMain);\n            } catch(err) {\n                throw new error.PluginError(err, {\n                    plugin: name\n                });\n            }\n        }\n\n        // Update plugin\n        return plugin.merge({\n            'package': Immutable.fromJS(packageContent),\n            'content': Immutable.fromJS(content || {})\n        });\n    })\n\n    .then(validatePlugin);\n\n    p = timing.measure('plugin.load', p);\n\n    logger.info('loading plugin \"' + name + '\"... ');\n    return logger.info.promise(p);\n}\n\n\nmodule.exports = loadPlugin;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/validatePlugin.js":"var gitbook = require('../gitbook');\n\nvar Promise = require('../utils/promise');\n\n/**\n    Validate a plugin\n\n    @param {Plugin}\n    @return {Promise<Plugin>}\n*/\nfunction validatePlugin(plugin) {\n    var packageInfos = plugin.getPackage();\n\n    var isValid = (\n        plugin.isLoaded() &&\n        packageInfos &&\n        packageInfos.get('name') &&\n        packageInfos.get('engines') &&\n        packageInfos.get('engines').get('gitbook')\n    );\n\n    if (!isValid) {\n        return Promise.reject(new Error('Error loading plugin \"' + plugin.getName() + '\" at \"' + plugin.getPath() + '\"'));\n    }\n\n    var engine = packageInfos.get('engines').get('gitbook');\n    if (!gitbook.satisfies(engine)) {\n        return Promise.reject(new Error('GitBook doesn\\'t satisfy the requirements of this plugin: ' + engine));\n    }\n\n    return Promise(plugin);\n}\n\nmodule.exports = validatePlugin;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/validateConfig.js":"var Immutable = require('immutable');\nvar jsonschema = require('jsonschema');\nvar jsonSchemaDefaults = require('json-schema-defaults');\n\nvar Promise = require('../utils/promise');\nvar error = require('../utils/error');\nvar mergeDefaults = require('../utils/mergeDefaults');\n\n/**\n    Validate one plugin for a book and update book's confiration\n\n    @param {Book}\n    @param {Plugin}\n    @return {Book}\n*/\nfunction validatePluginConfig(book, plugin) {\n    var config = book.getConfig();\n    var packageInfos = plugin.getPackage();\n\n    var configKey = [\n        'pluginsConfig',\n        plugin.getName()\n    ].join('.');\n\n    var pluginConfig = config.getValue(configKey, {}).toJS();\n\n    var schema = (packageInfos.get('gitbook') || Immutable.Map()).toJS();\n    if (!schema) return book;\n\n    // Normalize schema\n    schema.id = '/' + configKey;\n    schema.type = 'object';\n\n    // Validate and throw if invalid\n    var v = new jsonschema.Validator();\n    var result = v.validate(pluginConfig, schema, {\n        propertyName: configKey\n    });\n\n    // Throw error\n    if (result.errors.length > 0) {\n        throw new error.ConfigurationError(new Error(result.errors[0].stack));\n    }\n\n    // Insert default values\n    var defaults = jsonSchemaDefaults(schema);\n    pluginConfig = mergeDefaults(pluginConfig, defaults);\n\n\n    // Update configuration\n    config = config.setValue(configKey, pluginConfig);\n\n    // Return new book\n    return book.set('config', config);\n}\n\n/**\n    Validate a book configuration for plugins and\n    returns an update configuration with default values.\n\n    @param {Book}\n    @param {OrderedMap<String:Plugin>}\n    @return {Promise<Book>}\n*/\nfunction validateConfig(book, plugins) {\n    return Promise.reduce(plugins, function(newBook, plugin) {\n        return validatePluginConfig(newBook, plugin);\n    }, book);\n}\n\nmodule.exports = validateConfig;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/installPlugins.js":"var npmi = require('npmi');\n\nvar DEFAULT_PLUGINS = require('../constants/defaultPlugins');\nvar Promise = require('../utils/promise');\nvar installPlugin = require('./installPlugin');\n\n/**\n    Install plugin requirements for a book\n\n    @param {Book}\n    @return {Promise<Number>}\n*/\nfunction installPlugins(book) {\n    var logger = book.getLogger();\n    var config = book.getConfig();\n    var plugins = config.getPluginDependencies();\n\n    // Remove default plugins\n    // (only if version is same as installed)\n    plugins = plugins.filterNot(function(plugin) {\n        var dependency = DEFAULT_PLUGINS.find(function(dep) {\n            return dep.getName() === plugin.getName();\n        });\n\n        return (\n            // Disabled plugin\n            !plugin.isEnabled() ||\n\n            // Or default one installed in GitBook itself\n            (dependency &&\n            plugin.getVersion() === dependency.getVersion())\n        );\n    });\n\n    if (plugins.size == 0) {\n        logger.info.ln('nothing to install!');\n        return Promise();\n    }\n\n    logger.info.ln('installing', plugins.size, 'plugins using npm@' + npmi.NPM_VERSION);\n\n    return Promise.forEach(plugins, function(plugin) {\n        return installPlugin(book, plugin);\n    })\n    .thenResolve(plugins.size);\n}\n\nmodule.exports = installPlugins;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/installPlugin.js":"var npmi = require('npmi');\n\nvar Promise = require('../utils/promise');\nvar resolveVersion = require('./resolveVersion');\n\n/**\n    Install a plugin for a book\n\n    @param {Book}\n    @param {PluginDependency}\n    @return {Promise}\n*/\nfunction installPlugin(book, plugin) {\n    var logger = book.getLogger();\n\n    var installFolder = book.getRoot();\n    var name = plugin.getName();\n    var requirement = plugin.getVersion();\n\n    logger.info.ln('');\n    logger.info.ln('installing plugin \"' + name + '\"');\n\n    // Find a version to install\n    return resolveVersion(plugin)\n    .then(function(version) {\n        if (!version) {\n            throw new Error('Found no satisfactory version for plugin \"' + name + '\" with requirement \"' + requirement + '\"');\n        }\n\n        logger.info.ln('install plugin \"' + name +'\" (' + requirement + ') from NPM with version', version);\n        return Promise.nfcall(npmi, {\n            'name': plugin.getNpmID(),\n            'version': version,\n            'path': installFolder,\n            'npmLoad': {\n                'loglevel': 'silent',\n                'loaded': true,\n                'prefix': installFolder\n            }\n        });\n    })\n    .then(function() {\n        logger.info.ok('plugin \"' + name + '\" installed with success');\n    });\n}\n\nmodule.exports = installPlugin;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/resolveVersion.js":"var npm = require('npm');\nvar semver = require('semver');\nvar Immutable = require('immutable');\n\nvar Promise = require('../utils/promise');\nvar Plugin = require('../models/plugin');\nvar gitbook = require('../gitbook');\n\nvar npmIsReady;\n\n/**\n    Initialize and prepare NPM\n\n    @return {Promise}\n*/\nfunction initNPM() {\n    if (npmIsReady) return npmIsReady;\n\n    npmIsReady = Promise.nfcall(npm.load, {\n        silent: true,\n        loglevel: 'silent'\n    });\n\n    return npmIsReady;\n}\n\n/**\n    Resolve a plugin dependency to a version\n\n    @param {PluginDependency} plugin\n    @return {Promise<String>}\n*/\nfunction resolveVersion(plugin) {\n    var npmId = Plugin.nameToNpmID(plugin.getName());\n    var requiredVersion = plugin.getVersion();\n\n    if (plugin.isGitDependency()) {\n        return Promise.resolve(requiredVersion);\n    }\n\n    return initNPM()\n    .then(function() {\n        return Promise.nfcall(npm.commands.view, [npmId + '@' + requiredVersion, 'engines'], true);\n    })\n    .then(function(versions) {\n        versions = Immutable.Map(versions).entrySeq();\n\n        var result = versions\n            .map(function(entry) {\n                return {\n                    version: entry[0],\n                    gitbook: (entry[1].engines || {}).gitbook\n                };\n            })\n            .filter(function(v) {\n                return v.gitbook && gitbook.satisfies(v.gitbook);\n            })\n            .sort(function(v1, v2) {\n                return semver.lt(v1.version, v2.version)? 1 : -1;\n            })\n            .get(0);\n\n        if (!result) {\n            return undefined;\n        } else {\n            return result.version;\n        }\n    });\n}\n\nmodule.exports = resolveVersion;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/listResources.js":"var Immutable = require('immutable');\nvar path = require('path');\n\nvar LocationUtils = require('../utils/location');\nvar PLUGIN_RESOURCES = require('../constants/pluginResources');\n\n/**\n    List all resources from a list of plugins\n\n    @param {OrderedMap<String:Plugin>}\n    @param {String} type\n    @return {Map<String:List<{url, path}>}\n*/\nfunction listResources(plugins, resources) {\n    return plugins.reduce(function(result, plugin) {\n        var npmId           = plugin.getNpmID();\n        var pluginResources = resources.get(plugin.getName());\n\n        PLUGIN_RESOURCES.forEach(function(resourceType) {\n            var assets = pluginResources.get(resourceType);\n            if (!assets) return;\n\n            var list = result.get(resourceType) || Immutable.List();\n\n            assets = assets.map(function(assetFile) {\n                if (LocationUtils.isExternal(assetFile)) {\n                    return {\n                        url: assetFile\n                    };\n                } else {\n                    return {\n                        path: LocationUtils.normalize(path.join(npmId, assetFile))\n                    };\n                }\n            });\n\n            list = list.concat(assets);\n            result = result.set(resourceType, list);\n        });\n\n        return result;\n    }, Immutable.Map());\n}\n\nmodule.exports = listResources;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/pluginResources.js":"var Immutable = require('immutable');\n\nmodule.exports = Immutable.List([\n    'js',\n    'css'\n]);\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/listBlocks.js":"var Immutable = require('immutable');\n\n/**\n    List blocks from a list of plugins\n\n    @param {OrderedMap<String:Plugin>}\n    @return {Map<String:TemplateBlock>}\n*/\nfunction listBlocks(plugins) {\n    return plugins\n        .reverse()\n        .reduce(function(result, plugin) {\n            var blocks = plugin.getBlocks();\n            return result.merge(blocks);\n        }, Immutable.Map());\n}\n\nmodule.exports = listBlocks;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/plugins/listFilters.js":"var Immutable = require('immutable');\n\n/**\n    List filters from a list of plugins\n\n    @param {OrderedMap<String:Plugin>}\n    @return {Map<String:Function>}\n*/\nfunction listFilters(plugins) {\n    return plugins\n        .reverse()\n        .reduce(function(result, plugin) {\n            return result.merge(plugin.getFilters());\n        }, Immutable.Map());\n}\n\nmodule.exports = listFilters;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/defaultBlocks.js":"var Immutable = require('immutable');\nvar TemplateBlock = require('../models/templateBlock');\n\nmodule.exports = Immutable.Map({\n    html: TemplateBlock({\n        name: 'html',\n        process: function(blk) {\n            return blk;\n        }\n    }),\n\n    code: TemplateBlock({\n        name: 'code',\n        process: function(blk) {\n            return {\n                html: false,\n                body: blk.body\n            };\n        }\n    }),\n\n    markdown: TemplateBlock({\n        name: 'markdown',\n        process: function(blk) {\n            return this.book.renderInline('markdown', blk.body)\n            .then(function(out) {\n                return { body: out };\n            });\n        }\n    }),\n\n    asciidoc: TemplateBlock({\n        name: 'asciidoc',\n        process: function(blk) {\n            return this.book.renderInline('asciidoc', blk.body)\n            .then(function(out) {\n                return { body: out };\n            });\n        }\n    }),\n\n    markup: TemplateBlock({\n        name: 'markup',\n        process: function(blk) {\n            return this.book.renderInline(this.ctx.file.type, blk.body)\n            .then(function(out) {\n                return { body: out };\n            });\n        }\n    })\n});\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/api/encodeConfig.js":"var objectPath = require('object-path');\nvar deprecate = require('./deprecate');\n\n/**\n    Encode a config object into a JS config api\n\n    @param {Output} output\n    @param {Config} config\n    @return {Object}\n*/\nfunction encodeConfig(output, config) {\n    var result = {\n        values: config.getValues().toJS(),\n\n        get: function(key, defaultValue) {\n            return objectPath.get(result.values, key, defaultValue);\n        },\n\n        set: function(key, value) {\n            return objectPath.set(result.values, key, value);\n        }\n    };\n\n    deprecate.field(output, 'config.options', result, 'options',\n        result.values, '\"config.options\" property is deprecated, use \"config.get(key)\" instead');\n\n    deprecate.field(output, 'config.options.generator', result.values, 'generator',\n        output.getGenerator(), '\"options.generator\" property is deprecated, use \"output.name\" instead');\n\n    deprecate.field(output, 'config.options.generator', result.values, 'output',\n        output.getRoot(), '\"options.output\" property is deprecated, use \"output.root()\" instead');\n\n    return result;\n}\n\nmodule.exports = encodeConfig;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/api/encodeSummary.js":"var encodeSummaryArticle = require('../json/encodeSummaryArticle');\n\n/**\n    Encode summary to provide an API to plugin\n\n    @param {Output} output\n    @param {Config} config\n    @return {Object}\n*/\nfunction encodeSummary(output, summary) {\n    var result = {\n        /**\n            Iterate over the summary, it stops when the \"iter\" returns false\n\n            @param {Function} iter\n        */\n        walk: function (iter) {\n            summary.getArticle(function(article) {\n                var jsonArticle = encodeSummaryArticle(article, false);\n\n                return iter(jsonArticle);\n            });\n        },\n\n        /**\n            Get an article by its level\n\n            @param {String} level\n            @return {Object}\n        */\n        getArticleByLevel: function(level) {\n            var article = summary.getByLevel(level);\n            return (article? encodeSummaryArticle(article) : undefined);\n        },\n\n        /**\n            Get an article by its path\n\n            @param {String} level\n            @return {Object}\n        */\n        getArticleByPath: function(level) {\n            var article = summary.getByPath(level);\n            return (article? encodeSummaryArticle(article) : undefined);\n        }\n    };\n\n    return result;\n}\n\nmodule.exports = encodeSummary;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/api/decodeGlobal.js":"var decodeConfig = require('./decodeConfig');\n\n/**\n    Decode changes from a JS API to a output object.\n    Only the configuration can be edited by plugin's hooks\n\n    @param {Output} output\n    @param {Object} result: result from API\n    @return {Output}\n*/\nfunction decodeGlobal(output, result) {\n    var book = output.getBook();\n    var config = book.getConfig();\n\n    // Update config\n    config = decodeConfig(config, result.config);\n    book = book.set('config', config);\n\n    return output.set('book', book);\n}\n\nmodule.exports = decodeGlobal;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/api/decodeConfig.js":"/**\n    Decode changes from a JS API to a config object\n\n    @param {Config} config\n    @param {Object} result: result from API\n    @return {Config}\n*/\nfunction decodeGlobal(config, result) {\n    var values = result.values;\n\n    delete values.generator;\n    delete values.output;\n\n    return config.updateValues(values);\n}\n\nmodule.exports = decodeGlobal;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/json/onFinish.js":"var path = require('path');\n\nvar Promise = require('../../utils/promise');\nvar fs = require('../../utils/fs');\nvar JSONUtils = require('../../json');\n\n/**\n    Finish the generation\n\n    @param {Output}\n    @return {Output}\n*/\nfunction onFinish(output) {\n    var book = output.getBook();\n    var outputRoot = output.getRoot();\n\n    if (!book.isMultilingual()) {\n        return Promise(output);\n    }\n\n    // Get main language\n    var languages = book.getLanguages();\n    var mainLanguage = languages.getDefaultLanguage();\n\n    // Read the main JSON\n    return fs.readFile(path.resolve(outputRoot, mainLanguage.getID(), 'README.json'), 'utf8')\n\n    // Extend the JSON\n    .then(function(content) {\n        var json = JSON.parse(content);\n\n        json.languages = JSONUtils.encodeLanguages(languages);\n\n        return json;\n    })\n\n    .then(function(json) {\n        return fs.writeFile(\n            path.resolve(outputRoot, 'README.json'),\n            JSON.stringify(json, null, 4)\n        );\n    })\n\n    .thenResolve(output);\n}\n\nmodule.exports = onFinish;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/website/index.js":"\nmodule.exports = {\n    name:                       'website',\n    State:                      require('./state'),\n    Options:                    require('./options'),\n    onInit:                     require('./onInit'),\n    onFinish:                   require('./onFinish'),\n    onPage:                     require('./onPage'),\n    onAsset:                    require('./onAsset'),\n    createTemplateEngine:       require('./createTemplateEngine')\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/website/state.js":"var I18n = require('i18n-t');\nvar Immutable = require('immutable');\n\nvar GeneratorState = Immutable.Record({\n    i18n:       I18n(),\n\n    // List of plugins' resources\n    resources:  Immutable.Map()\n});\n\nGeneratorState.prototype.getI18n = function() {\n    return this.get('i18n');\n};\n\nGeneratorState.prototype.getResources = function() {\n    return this.get('resources');\n};\n\nmodule.exports = GeneratorState;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/website/options.js":"var Immutable = require('immutable');\n\nvar Options = Immutable.Record({\n    // Root folder for the output\n    root:               String(),\n\n    // Prefix for generation\n    prefix:             String('website'),\n\n    // Use directory index url instead of \"index.html\"\n    directoryIndex:     Boolean(true)\n});\n\nmodule.exports = Options;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/website/onInit.js":"var Promise = require('../../utils/promise');\n\nvar copyPluginAssets = require('./copyPluginAssets');\nvar prepareI18n = require('./prepareI18n');\nvar prepareResources = require('./prepareResources');\n\n/**\n    Initialize the generator\n\n    @param {Output}\n    @return {Output}\n*/\nfunction onInit(output) {\n    return Promise(output)\n    .then(prepareI18n)\n    .then(prepareResources)\n    .then(copyPluginAssets);\n}\n\nmodule.exports = onInit;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/website/copyPluginAssets.js":"var path = require('path');\n\nvar ASSET_FOLDER = require('../../constants/pluginAssetsFolder');\nvar Promise = require('../../utils/promise');\nvar fs = require('../../utils/fs');\n\n/**\n    Copy all assets from plugins.\n    Assets are files stored in \"_assets\"\n    nd resources declared in the plugin itself.\n\n    @param {Output}\n    @return {Promise}\n*/\nfunction copyPluginAssets(output) {\n    var book = output.getBook();\n\n    // Don't copy plugins assets for language book\n    // It'll be resolved to the parent folder\n    if (book.isLanguageBook()) {\n        return Promise(output);\n    }\n\n    var plugins = output.getPlugins()\n\n        // We reverse the order of plugins to copy\n        // so that first plugins can replace assets from other plugins.\n        .reverse();\n\n    return Promise.forEach(plugins, function(plugin) {\n        return copyAssets(output, plugin)\n        .then(function() {\n            return copyResources(output, plugin);\n        });\n    })\n    .thenResolve(output);\n}\n\n/**\n    Copy assets from a plugin\n\n    @param {Plugin}\n    @return {Promise}\n*/\nfunction copyAssets(output, plugin) {\n    var logger = output.getLogger();\n    var pluginRoot = plugin.getPath();\n    var options = output.getOptions();\n\n    var outputRoot = options.get('root');\n    var assetOutputFolder = path.join(outputRoot, 'gitbook');\n    var prefix = options.get('prefix');\n\n    var assetFolder = path.join(pluginRoot, ASSET_FOLDER, prefix);\n\n    if (!fs.existsSync(assetFolder)) {\n        return Promise();\n    }\n\n    logger.debug.ln('copy assets from theme', assetFolder);\n    return fs.copyDir(\n        assetFolder,\n        assetOutputFolder,\n        {\n            deleteFirst: false,\n            overwrite: true,\n            confirm: true\n        }\n    );\n}\n\n/**\n    Copy resources from a plugin\n\n    @param {Plugin}\n    @return {Promise}\n*/\nfunction copyResources(output, plugin) {\n    var logger = output.getLogger();\n\n    var options    = output.getOptions();\n    var outputRoot = options.get('root');\n\n    var state = output.getState();\n    var resources = state.getResources();\n\n    var pluginRoot      = plugin.getPath();\n    var pluginResources = resources.get(plugin.getName());\n\n    var assetsFolder = pluginResources.get('assets');\n    var assetOutputFolder = path.join(outputRoot, 'gitbook', plugin.getNpmID());\n\n    if (!assetsFolder) {\n        return Promise();\n    }\n\n    // Resolve assets folder\n    assetsFolder = path.resolve(pluginRoot, assetsFolder);\n    if (!fs.existsSync(assetsFolder)) {\n        logger.warn.ln('assets folder for plugin \"' + plugin.getName() + '\" doesn\\'t exist');\n        return Promise();\n    }\n\n    logger.debug.ln('copy resources from plugin', assetsFolder);\n\n    return fs.copyDir(\n        assetsFolder,\n        assetOutputFolder,\n        {\n            deleteFirst: false,\n            overwrite: true,\n            confirm: true\n        }\n    );\n}\n\nmodule.exports = copyPluginAssets;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/pluginAssetsFolder.js":"\nmodule.exports = '_assets';\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/website/prepareI18n.js":"var path = require('path');\n\nvar fs = require('../../utils/fs');\nvar Promise = require('../../utils/promise');\nvar listSearchPaths = require('./listSearchPaths');\n\n/**\n * Prepare i18n, load translations from plugins and book\n *\n * @param {Output}\n * @return {Promise<Output>}\n */\nfunction prepareI18n(output) {\n    var state = output.getState();\n    var i18n = state.getI18n();\n    var searchPaths = listSearchPaths(output);\n\n    searchPaths\n        .reverse()\n        .forEach(function(searchPath) {\n            var i18nRoot = path.resolve(searchPath, '_i18n');\n\n            if (!fs.existsSync(i18nRoot)) return;\n            i18n.load(i18nRoot);\n        });\n\n    return Promise(output);\n}\n\nmodule.exports = prepareI18n;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/website/listSearchPaths.js":"\n/**\n    List search paths for templates / i18n, etc\n\n    @param {Output} output\n    @return {List<String>}\n*/\nfunction listSearchPaths(output) {\n    var book = output.getBook();\n    var plugins = output.getPlugins();\n\n    var searchPaths = plugins\n        .valueSeq()\n        .map(function(plugin) {\n            return plugin.getPath();\n        })\n        .toList();\n\n    return searchPaths.unshift(book.getContentRoot());\n}\n\n\nmodule.exports = listSearchPaths;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/website/prepareResources.js":"var is        = require('is');\nvar Immutable = require('immutable');\nvar Promise   = require('../../utils/promise');\n\nvar Api              = require('../../api');\n\n/**\n    Prepare plugins resources, add all output corresponding type resources\n\n    @param {Output}\n    @return {Promise<Output>}\n*/\nfunction prepareResources(output) {\n    var plugins = output.getPlugins();\n    var options = output.getOptions();\n    var type    = options.get('prefix');\n    var state   = output.getState();\n    var context = Api.encodeGlobal(output);\n\n    var result = Immutable.Map();\n\n    return Promise.forEach(plugins, function(plugin) {\n        var pluginResources = plugin.getResources(type);\n\n        return Promise()\n        .then(function() {\n            // Apply resources if is a function\n            if (is.fn(pluginResources)) {\n                return Promise()\n                .then(pluginResources.bind(context));\n            }\n            else {\n                return pluginResources;\n            }\n        })\n        .then(function(resources) {\n            result = result.set(plugin.getName(), Immutable.Map(resources));\n        });\n    })\n    .then(function() {\n        // Set output resources\n        state = state.merge({\n            resources: result\n        });\n\n        output = output.merge({\n            state: state\n        });\n\n        return output;\n    });\n}\n\nmodule.exports = prepareResources;","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/website/onFinish.js":"var Promise = require('../../utils/promise');\nvar JSONUtils = require('../../json');\nvar Templating = require('../../templating');\nvar writeFile = require('../helper/writeFile');\nvar createTemplateEngine = require('./createTemplateEngine');\n\n/**\n    Finish the generation, write the languages index\n\n    @param {Output}\n    @return {Output}\n*/\nfunction onFinish(output) {\n    var book = output.getBook();\n    var options = output.getOptions();\n    var prefix = options.get('prefix');\n\n    if (!book.isMultilingual()) {\n        return Promise(output);\n    }\n\n    var filePath = 'index.html';\n    var engine = createTemplateEngine(output, filePath);\n    var context = JSONUtils.encodeOutput(output);\n\n    // Render the theme\n    return Templating.renderFile(engine, prefix + '/languages.html', context)\n\n    // Write it to the disk\n    .then(function(tplOut) {\n        return writeFile(output, filePath, tplOut.getContent());\n    });\n}\n\nmodule.exports = onFinish;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/templating/index.js":"\nmodule.exports = {\n    render:             require('./render'),\n    renderFile:         require('./renderFile'),\n    postRender:         require('./postRender'),\n    replaceShortcuts:   require('./replaceShortcuts'),\n\n    ConrefsLoader:      require('./conrefsLoader'),\n    ThemesLoader:       require('./themesLoader')\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/templating/render.js":"var Promise = require('../utils/promise');\nvar timing = require('../utils/timing');\nvar TemplateOutput = require('../models/templateOutput');\nvar replaceShortcuts = require('./replaceShortcuts');\n\n/**\n * Render a template\n *\n * @param {TemplateEngine} engine\n * @param {String} filePath: absolute path for the loader\n * @param {String} content\n * @param {Object} context (optional)\n * @return {Promise<TemplateOutput>}\n */\nfunction renderTemplate(engine, filePath, content, context) {\n    context = context || {};\n\n    // Mutable objects to contains all blocks requiring post-processing\n    var blocks = {};\n\n    // Create nunjucks environment\n    var env = engine.toNunjucks(blocks);\n\n    // Replace shortcuts from plugin's blocks\n    content = replaceShortcuts(engine.getBlocks(), filePath, content);\n\n    return timing.measure(\n        'template.render',\n\n        Promise.nfcall(\n            env.renderString.bind(env),\n            content,\n            context,\n            {\n                path: filePath\n            }\n        )\n        .then(function(content) {\n            return TemplateOutput.create(content, blocks);\n        })\n    );\n}\n\nmodule.exports = renderTemplate;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/templateOutput.js":"var Immutable = require('immutable');\n\nvar TemplateOutput = Immutable.Record({\n    // Text content of the template\n    content:        String(),\n\n    // Map of blocks to replace / post process\n    blocks:         Immutable.Map()\n}, 'TemplateOutput');\n\nTemplateOutput.prototype.getContent = function() {\n    return this.get('content');\n};\n\nTemplateOutput.prototype.getBlocks = function() {\n    return this.get('blocks');\n};\n\n/**\n * Update content of this output\n * @param {String} content\n * @return {TemplateContent}\n */\nTemplateOutput.prototype.setContent = function(content) {\n    return this.set('content', content);\n};\n\n/**\n * Create a TemplateOutput from a text content\n * and an object containing block definition\n * @param {String} content\n * @param {Object} blocks\n * @return {TemplateOutput}\n */\nTemplateOutput.create = function(content, blocks) {\n    return new TemplateOutput({\n        content:    content,\n        blocks:     Immutable.fromJS(blocks)\n    });\n};\n\nmodule.exports = TemplateOutput;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/templating/replaceShortcuts.js":"var escapeStringRegexp = require('escape-string-regexp');\nvar listShortcuts = require('./listShortcuts');\n\n/**\n * Apply a shortcut of block to a template\n * @param {String} content\n * @param {Shortcut} shortcut\n * @return {String}\n */\nfunction applyShortcut(content, shortcut) {\n    var start = shortcut.getStart();\n    var end = shortcut.getEnd();\n\n    var tagStart = shortcut.getStartTag();\n    var tagEnd = shortcut.getEndTag();\n\n    var regex = new RegExp(\n        escapeStringRegexp(start) + '([\\\\s\\\\S]*?[^\\\\$])' + escapeStringRegexp(end),\n       'g'\n    );\n    return content.replace(regex, function(all, match) {\n        return '{% ' + tagStart + ' %}' + match + '{% ' + tagEnd + ' %}';\n    });\n}\n\n/**\n * Replace shortcuts from blocks in a string\n *\n * @param {List<TemplateBlock>} engine\n * @param {String} filePath\n * @param {String} content\n * @return {String}\n */\nfunction replaceShortcuts(blocks, filePath, content) {\n    var shortcuts = listShortcuts(blocks, filePath);\n    return shortcuts.reduce(applyShortcut, content);\n}\n\nmodule.exports = replaceShortcuts;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/templating/listShortcuts.js":"var Immutable = require('immutable');\nvar parsers = require('../parsers');\n\n/**\n * Return a list of all shortcuts that can apply\n * to a file for a TemplatEngine\n *\n * @param {List<TemplateBlock>} engine\n * @param {String} filePath\n * @return {List<TemplateShortcut>}\n */\nfunction listShortcuts(blocks, filePath) {\n    var parser = parsers.getForFile(filePath);\n\n    if (!parser) {\n        return Immutable.List();\n    }\n\n    return blocks\n        .map(function(block) {\n            return block.getShortcuts();\n        })\n        .filter(function(shortcuts) {\n            return (\n                shortcuts &&\n                shortcuts.acceptParser(parser.getName())\n            );\n        });\n}\n\nmodule.exports = listShortcuts;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/templating/renderFile.js":"var Promise = require('../utils/promise');\nvar error = require('../utils/error');\nvar render = require('./render');\n\n/**\n * Render a template\n *\n * @param {TemplateEngine} engine\n * @param {String} filePath\n * @param {Object} context\n * @return {Promise<TemplateOutput>}\n */\nfunction renderTemplateFile(engine, filePath, context) {\n    var loader = engine.getLoader();\n\n    // Resolve the filePath\n    var resolvedFilePath = loader.resolve(null, filePath);\n\n    return Promise()\n    .then(function() {\n        if (!loader.async) {\n            return loader.getSource(resolvedFilePath);\n        }\n\n        var deferred = Promise.defer();\n        loader.getSource(resolvedFilePath, deferred.makeNodeResolver());\n        return deferred.promise;\n    })\n    .then(function(result) {\n        if (!result) {\n            throw error.TemplateError(new Error('Not found'), {\n                filename: filePath\n            });\n        }\n\n        return render(engine, result.path, result.src, context);\n    });\n\n}\n\nmodule.exports = renderTemplateFile;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/templating/postRender.js":"var Promise = require('../utils/promise');\n\n\n/**\n * Replace position markers of blocks by body after processing\n * This is done to avoid that markdown/asciidoc processer parse the block content\n *\n * @param {String} content\n * @return {Object} {blocks: Set, content: String}\n */\nfunction replaceBlocks(content, blocks) {\n    var newContent = content.replace(/\\{\\{\\-\\%([\\s\\S]+?)\\%\\-\\}\\}/g, function(match, key) {\n        var replacedWith = match;\n\n        var block = blocks.get(key);\n        if (block) {\n            replacedWith = replaceBlocks(block.get('body'), blocks);\n        }\n\n        return replacedWith;\n    });\n\n    return newContent;\n}\n\n/**\n * Post render a template:\n *     - Execute \"post\" for blocks\n *     - Replace block content\n *\n * @param {TemplateEngine} engine\n * @param {TemplateOutput} content\n * @return {Promise<String>}\n */\nfunction postRender(engine, output) {\n    var content = output.getContent();\n    var blocks = output.getBlocks();\n\n    var result = replaceBlocks(content, blocks);\n\n    return Promise.forEach(blocks, function(block) {\n        var post = block.get('post');\n\n        if (!post) {\n            return;\n        }\n\n        return post();\n    })\n    .thenResolve(result);\n}\n\nmodule.exports = postRender;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/templating/conrefsLoader.js":"var path = require('path');\nvar nunjucks = require('nunjucks');\n\nvar fs = require('../utils/fs');\nvar Git = require('../utils/git');\nvar LocationUtils = require('../utils/location');\nvar PathUtils = require('../utils/path');\n\n\n/**\n * Template loader resolving both:\n *      - relative url (\"./test.md\")\n *      - absolute url (\"/test.md\")\n *      - git url (\"\")\n *\n * @param {String} rootFolder\n * @param {Function(filePath, source)} transformFn (optional)\n * @param {Logger} logger (optional)\n */\nvar ConrefsLoader = nunjucks.Loader.extend({\n    async: true,\n\n    init: function(rootFolder, transformFn, logger) {\n        this.rootFolder = rootFolder;\n        this.transformFn = transformFn;\n        this.logger = logger;\n        this.git = new Git();\n    },\n\n    getSource: function(sourceURL, callback) {\n        var that = this;\n\n        this.git.resolve(sourceURL)\n        .then(function(filepath) {\n            // Is local file\n            if (!filepath) {\n                filepath = path.resolve(sourceURL);\n            } else {\n                if (that.logger) that.logger.debug.ln('resolve from git', sourceURL, 'to', filepath);\n            }\n\n            // Read file from absolute path\n            return fs.readFile(filepath)\n            .then(function(source) {\n                source = source.toString('utf8');\n\n                if (that.transformFn) {\n                    return that.transformFn(filepath, source);\n                }\n\n                return source;\n            })\n            .then(function(source) {\n                return {\n                    src: source,\n                    path: filepath\n                };\n            });\n        })\n        .nodeify(callback);\n    },\n\n    resolve: function(from, to) {\n        // If origin is in the book, we enforce result file to be in the book\n        if (PathUtils.isInRoot(this.rootFolder, from)) {\n\n            // Path of current template in the rootFolder (not absolute to fs)\n            var fromRelative = path.relative(this.rootFolder, from);\n\n            // Resolve \"to\" to a filepath relative to rootFolder\n            var href = LocationUtils.toAbsolute(to, path.dirname(fromRelative), '');\n\n            // Return absolute path\n            return PathUtils.resolveInRoot(this.rootFolder, href);\n        }\n\n        // If origin is in a git repository, we resolve file in the git repository\n        var gitRoot = this.git.resolveRoot(from);\n        if (gitRoot) {\n            return PathUtils.resolveInRoot(gitRoot, to);\n        }\n\n        // If origin is not in the book (include from a git content ref)\n        return path.resolve(path.dirname(from), to);\n    },\n\n    // Handle all files as relative, so that nunjucks pass responsability to 'resolve'\n    isRelative: function(filename) {\n        return LocationUtils.isRelative(filename);\n    }\n});\n\nmodule.exports = ConrefsLoader;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/utils/git.js":"var is = require('is');\nvar path = require('path');\nvar crc = require('crc');\nvar URI = require('urijs');\n\nvar pathUtil = require('./path');\nvar Promise = require('./promise');\nvar command = require('./command');\nvar fs = require('./fs');\n\nvar GIT_PREFIX = 'git+';\n\nfunction Git() {\n    this.tmpDir;\n    this.cloned = {};\n}\n\n// Return an unique ID for a combinaison host/ref\nGit.prototype.repoID = function(host, ref) {\n    return crc.crc32(host+'#'+(ref || '')).toString(16);\n};\n\n// Allocate a temporary folder for cloning repos in it\nGit.prototype.allocateDir = function() {\n    var that = this;\n\n    if (this.tmpDir) return Promise();\n\n    return fs.tmpDir()\n    .then(function(dir) {\n        that.tmpDir = dir;\n    });\n};\n\n// Clone a git repository if non existant\nGit.prototype.clone = function(host, ref) {\n    var that = this;\n\n    return this.allocateDir()\n\n    // Return or clone the git repo\n    .then(function() {\n        // Unique ID for repo/ref combinaison\n        var repoId = that.repoID(host, ref);\n\n        // Absolute path to the folder\n        var repoPath = path.join(that.tmpDir, repoId);\n\n        if (that.cloned[repoId]) return repoPath;\n\n        // Clone repo\n        return command.exec('git clone '+host+' '+repoPath)\n\n        // Checkout reference if specified\n        .then(function() {\n            that.cloned[repoId] = true;\n\n            if (!ref) return;\n            return command.exec('git checkout '+ref, { cwd: repoPath });\n        })\n        .thenResolve(repoPath);\n    });\n};\n\n// Get file from a git repo\nGit.prototype.resolve = function(giturl) {\n    // Path to a file in a git repo?\n    if (!Git.isUrl(giturl)) {\n        if (this.resolveRoot(giturl)) return Promise(giturl);\n        return Promise(null);\n    }\n    if (is.string(giturl)) giturl = Git.parseUrl(giturl);\n    if (!giturl) return Promise(null);\n\n    // Clone or get from cache\n    return this.clone(giturl.host, giturl.ref)\n    .then(function(repo) {\n        return path.resolve(repo, giturl.filepath);\n    });\n};\n\n// Return root of git repo from a filepath\nGit.prototype.resolveRoot = function(filepath) {\n    var relativeToGit, repoId;\n\n    // No git repo cloned, or file is not in a git repository\n    if (!this.tmpDir || !pathUtil.isInRoot(this.tmpDir, filepath)) return null;\n\n    // Extract first directory (is the repo id)\n    relativeToGit = path.relative(this.tmpDir, filepath);\n    repoId = relativeToGit.split(path.sep)[0];\n    if (!repoId) {\n        return;\n    }\n\n    // Return an absolute file\n    return path.resolve(this.tmpDir, repoId);\n};\n\n// Check if an url is a git dependency url\nGit.isUrl = function(giturl) {\n    return (giturl.indexOf(GIT_PREFIX) === 0);\n};\n\n// Parse and extract infos\nGit.parseUrl = function(giturl) {\n    var ref, uri, fileParts, filepath;\n\n    if (!Git.isUrl(giturl)) return null;\n    giturl = giturl.slice(GIT_PREFIX.length);\n\n    uri = new URI(giturl);\n    ref = uri.fragment() || null;\n    uri.fragment(null);\n\n    // Extract file inside the repo (after the .git)\n    fileParts = uri.path().split('.git');\n    filepath = fileParts.length > 1? fileParts.slice(1).join('.git') : '';\n    if (filepath[0] == '/') {\n        filepath = filepath.slice(1);\n    }\n\n    // Recreate pathname without the real filename\n    uri.path(fileParts[0] + '.git');\n\n    return {\n        host: uri.toString(),\n        ref: ref,\n        filepath: filepath\n    };\n};\n\nmodule.exports = Git;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/templating/themesLoader.js":"var Immutable = require('immutable');\nvar nunjucks = require('nunjucks');\nvar fs = require('fs');\nvar path = require('path');\n\nvar PathUtils = require('../utils/path');\n\n\nvar ThemesLoader = nunjucks.Loader.extend({\n    init: function(searchPaths) {\n        this.searchPaths = Immutable.List(searchPaths)\n            .map(path.normalize);\n    },\n\n    /**\n     * Read source of a resolved filepath\n     * @param {String}\n     * @return {Object}\n     */\n    getSource: function(fullpath) {\n        if (!fullpath) return null;\n\n        fullpath = this.resolve(null, fullpath);\n        var templateName = this.getTemplateName(fullpath);\n\n        if(!fullpath) {\n            return null;\n        }\n\n        var src = fs.readFileSync(fullpath, 'utf-8');\n\n        src = '{% do %}var template = template || {}; template.stack = template.stack || []; template.stack.push(template.self); template.self = ' + JSON.stringify(templateName) + '{% enddo %}\\n' +\n            src +\n            '\\n{% do %}template.self = template.stack.pop();{% enddo %}';\n\n        return {\n            src: src,\n            path: fullpath,\n            noCache: true\n        };\n    },\n\n    /**\n     * Nunjucks calls \"isRelative\" to determine when to call \"resolve\".\n     * We handle absolute paths ourselves in \".resolve\" so we always return true\n     */\n    isRelative: function() {\n        return true;\n    },\n\n    /**\n     * Get original search path containing a template\n     * @param {String} filepath\n     * @return {String} searchPath\n     */\n    getSearchPath: function(filepath) {\n        return this.searchPaths\n            .sortBy(function(s) {\n                return -s.length;\n            })\n            .find(function(basePath) {\n                return (filepath && filepath.indexOf(basePath) === 0);\n            });\n    },\n\n    /**\n     * Get template name from a filepath\n     * @param {String} filepath\n     * @return {String} name\n     */\n    getTemplateName: function(filepath) {\n        var originalSearchPath = this.getSearchPath(filepath);\n        return originalSearchPath? path.relative(originalSearchPath, filepath) : null;\n    },\n\n    /**\n     * Resolve a template from a current template\n     * @param {String|null} from\n     * @param {String} to\n     * @return {String|null}\n     */\n    resolve: function(from, to) {\n        var searchPaths = this.searchPaths;\n\n        // Relative template like \"./test.html\"\n        if (PathUtils.isPureRelative(to) && from) {\n            return path.resolve(path.dirname(from), to);\n        }\n\n        // Determine in which search folder we currently are\n        var originalSearchPath = this.getSearchPath(from);\n        var originalFilename = this.getTemplateName(from);\n\n        // If we are including same file from a different search path\n        // Slice the search paths to avoid including from previous ones\n        if (originalFilename == to) {\n            var currentIndex = searchPaths.indexOf(originalSearchPath);\n            searchPaths = searchPaths.slice(currentIndex + 1);\n        }\n\n        // Absolute template to resolve in root folder\n        var resultFolder = searchPaths.find(function(basePath) {\n            var p = path.resolve(basePath, to);\n\n            return (\n                p.indexOf(basePath) === 0\n                && fs.existsSync(p)\n            );\n        });\n        if (!resultFolder) return null;\n        return path.resolve(resultFolder, to);\n    }\n});\n\nmodule.exports = ThemesLoader;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/website/createTemplateEngine.js":"var path = require('path');\nvar nunjucks = require('nunjucks');\nvar DoExtension = require('nunjucks-do')(nunjucks);\n\nvar Api = require('../../api');\nvar deprecate = require('../../api/deprecate');\nvar JSONUtils = require('../../json');\nvar LocationUtils = require('../../utils/location');\nvar fs = require('../../utils/fs');\nvar PathUtils = require('../../utils/path');\nvar TemplateEngine = require('../../models/templateEngine');\nvar templatesFolder = require('../../constants/templatesFolder');\nvar defaultFilters = require('../../constants/defaultFilters');\nvar Templating = require('../../templating');\nvar listSearchPaths = require('./listSearchPaths');\n\nvar fileToURL = require('../helper/fileToURL');\nvar resolveFileToURL = require('../helper/resolveFileToURL');\n\n/**\n * Directory for a theme with the templates\n */\nfunction templateFolder(dir) {\n    return path.join(dir, templatesFolder);\n}\n\n/**\n * Create templating engine to render themes\n *\n * @param {Output} output\n * @param {String} currentFile\n * @return {TemplateEngine}\n */\nfunction createTemplateEngine(output, currentFile) {\n    var book = output.getBook();\n    var state = output.getState();\n    var i18n = state.getI18n();\n    var config = book.getConfig();\n    var summary = book.getSummary();\n    var outputFolder = output.getRoot();\n\n    // Search paths for templates\n    var searchPaths = listSearchPaths(output);\n    var tplSearchPaths = searchPaths.map(templateFolder);\n\n    // Create loader\n    var loader = new Templating.ThemesLoader(tplSearchPaths);\n\n    // Get languages\n    var language = config.getValue('language');\n\n    // Create API context\n    var context = Api.encodeGlobal(output);\n\n\n    /**\n     * Check if a file exists\n     * @param {String} fileName\n     * @return {Boolean}\n     */\n    function fileExists(fileName) {\n        if (!fileName) {\n            return false;\n        }\n\n        var filePath = PathUtils.resolveInRoot(outputFolder, fileName);\n        return fs.existsSync(filePath);\n    }\n\n    /**\n     * Return an article by its path\n     * @param {String} filePath\n     * @return {Object|undefined}\n     */\n    function getArticleByPath(filePath) {\n        var article = summary.getByPath(filePath);\n        if (!article) return undefined;\n\n        return JSONUtils.encodeSummaryArticle(article);\n    }\n\n    /**\n     * Return a page by its path\n     * @param {String} filePath\n     * @return {Object|undefined}\n     */\n    function getPageByPath(filePath) {\n        var page = output.getPage(filePath);\n        if (!page) return undefined;\n\n        return JSONUtils.encodePage(page, summary);\n    }\n\n    return TemplateEngine.create({\n        loader: loader,\n\n        context: context,\n\n        globals: {\n            getArticleByPath: getArticleByPath,\n            getPageByPath: getPageByPath,\n            fileExists: fileExists\n        },\n\n        filters: defaultFilters.merge({\n            /**\n             * Translate a sentence\n             */\n            t: function t(s) {\n                return i18n.t(language, s);\n            },\n\n            /**\n             * Resolve an absolute file path into a\n             * relative path.\n             * it also resolve pages\n             */\n            resolveFile: function(filePath) {\n                filePath = resolveFileToURL(output, filePath);\n                return LocationUtils.relativeForFile(currentFile, filePath);\n            },\n\n            resolveAsset: function(filePath) {\n                filePath = LocationUtils.toAbsolute(filePath, '', '');\n                filePath = path.join('gitbook', filePath);\n                filePath = LocationUtils.relativeForFile(currentFile, filePath);\n\n                // Use assets from parent if language book\n                if (book.isLanguageBook()) {\n                    filePath = path.join('../', filePath);\n                }\n\n                return LocationUtils.normalize(filePath);\n            },\n\n\n            fileExists: deprecate.method(book, 'fileExists', fileExists, 'Filter \"fileExists\" is deprecated, use \"fileExists(filename)\" '),\n            getArticleByPath: deprecate.method(book, 'getArticleByPath', fileExists, 'Filter \"getArticleByPath\" is deprecated, use \"getArticleByPath(filename)\" '),\n\n            contentURL: function(filePath) {\n                return fileToURL(output, filePath);\n            }\n        }),\n\n        extensions: {\n            'DoExtension': new DoExtension()\n        }\n    });\n}\n\nmodule.exports = createTemplateEngine;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/templateEngine.js":"var nunjucks = require('nunjucks');\nvar Immutable = require('immutable');\n\nvar TemplateEngine = Immutable.Record({\n    // Map of {TemplateBlock}\n    blocks:     Immutable.Map(),\n\n    // Map of Extension\n    extensions: Immutable.Map(),\n\n    // Map of filters: {String} name -> {Function} fn\n    filters:    Immutable.Map(),\n\n    // Map of globals: {String} name -> {Mixed}\n    globals:    Immutable.Map(),\n\n    // Context for filters / blocks\n    context:    Object(),\n\n    // Nunjucks loader\n    loader:     nunjucks.FileSystemLoader('views')\n}, 'TemplateEngine');\n\nTemplateEngine.prototype.getBlocks = function() {\n    return this.get('blocks');\n};\n\nTemplateEngine.prototype.getGlobals = function() {\n    return this.get('globals');\n};\n\nTemplateEngine.prototype.getFilters = function() {\n    return this.get('filters');\n};\n\nTemplateEngine.prototype.getShortcuts = function() {\n    return this.get('shortcuts');\n};\n\nTemplateEngine.prototype.getLoader = function() {\n    return this.get('loader');\n};\n\nTemplateEngine.prototype.getContext = function() {\n    return this.get('context');\n};\n\nTemplateEngine.prototype.getExtensions = function() {\n    return this.get('extensions');\n};\n\n/**\n    Return a block by its name (or undefined)\n\n    @param {String} name\n    @return {TemplateBlock}\n*/\nTemplateEngine.prototype.getBlock = function(name) {\n    var blocks = this.getBlocks();\n    return blocks.find(function(block) {\n        return block.getName() === name;\n    });\n};\n\n/**\n    Return a nunjucks environment from this configuration\n\n    @return {Nunjucks.Environment}\n*/\nTemplateEngine.prototype.toNunjucks = function(blocksOutput) {\n    var loader = this.getLoader();\n    var blocks = this.getBlocks();\n    var filters = this.getFilters();\n    var globals = this.getGlobals();\n    var extensions = this.getExtensions();\n    var context = this.getContext();\n\n    var env = new nunjucks.Environment(\n        loader,\n        {\n            // Escaping is done after by the asciidoc/markdown parser\n            autoescape: false,\n\n            // Syntax\n            tags: {\n                blockStart: '{%',\n                blockEnd: '%}',\n                variableStart: '{{',\n                variableEnd: '}}',\n                commentStart: '{###',\n                commentEnd: '###}'\n            }\n        }\n    );\n\n    // Add filters\n    filters.forEach(function(filterFn, filterName) {\n        env.addFilter(filterName, filterFn.bind(context));\n    });\n\n    // Add blocks\n    blocks.forEach(function(block) {\n        var extName = block.getExtensionName();\n        var Ext = block.toNunjucksExt(context, blocksOutput);\n\n        env.addExtension(extName, new Ext());\n    });\n\n    // Add globals\n    globals.forEach(function(globalValue, globalName) {\n        env.addGlobal(globalName, globalValue);\n    });\n\n    // Add other extensions\n    extensions.forEach(function(ext, extName) {\n        env.addExtension(extName, ext);\n    });\n\n    return env;\n};\n\n/**\n    Create a template engine\n\n    @param {Object} def\n    @return {TemplateEngine}\n*/\nTemplateEngine.create = function(def) {\n    return new TemplateEngine({\n        blocks:     Immutable.List(def.blocks || []),\n        extensions: Immutable.Map(def.extensions || {}),\n        filters:    Immutable.Map(def.filters || {}),\n        globals:    Immutable.Map(def.globals || {}),\n        context:    def.context,\n        loader:     def.loader\n    });\n};\n\nmodule.exports = TemplateEngine;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/templatesFolder.js":"\nmodule.exports = '_layouts';\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/constants/defaultFilters.js":"var Immutable = require('immutable');\nvar moment = require('moment');\n\nmodule.exports = Immutable.Map({\n    // Format a date\n    // ex: 'MMMM Do YYYY, h:mm:ss a\n    date: function(time, format) {\n        return moment(time).format(format);\n    },\n\n    // Relative Time\n    dateFromNow: function(time) {\n        return moment(time).fromNow();\n    }\n});\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/website/onPage.js":"var path = require('path');\nvar omit = require('omit-keys');\n\nvar Templating = require('../../templating');\nvar Plugins = require('../../plugins');\nvar JSONUtils = require('../../json');\nvar LocationUtils = require('../../utils/location');\nvar Modifiers = require('../modifiers');\nvar writeFile = require('../helper/writeFile');\nvar getModifiers = require('../getModifiers');\nvar createTemplateEngine = require('./createTemplateEngine');\nvar fileToOutput = require('../helper/fileToOutput');\n\n/**\n * Write a page as a json file\n *\n * @param {Output} output\n * @param {Page} page\n */\nfunction onPage(output, page) {\n    var options   = output.getOptions();\n    var prefix    = options.get('prefix');\n\n    var file      = page.getFile();\n\n    var book      = output.getBook();\n    var plugins   = output.getPlugins();\n    var state     = output.getState();\n    var resources = state.getResources();\n\n    var engine = createTemplateEngine(output, page.getPath());\n\n    // Output file path\n    var filePath = fileToOutput(output, file.getPath());\n\n    // Calcul relative path to the root\n    var outputDirName = path.dirname(filePath);\n    var basePath = LocationUtils.normalize(path.relative(outputDirName, './'));\n\n    return Modifiers.modifyHTML(page, getModifiers(output, page))\n    .then(function(resultPage) {\n        // Generate the context\n        var context = JSONUtils.encodeOutputWithPage(output, resultPage);\n        context.plugins = {\n            resources: Plugins.listResources(plugins, resources).toJS()\n        };\n\n        context.template = {\n            getJSContext: function() {\n                return {\n                    page: omit(context.page, 'content'),\n                    config: context.config,\n                    file: context.file,\n                    gitbook: context.gitbook,\n                    basePath: basePath,\n                    book: {\n                        language: book.getLanguage()\n                    }\n                };\n            }\n        };\n\n        // We should probabbly move it to \"template\" or a \"site\" namespace\n        context.basePath = basePath;\n\n        // Render the theme\n        return Templating.renderFile(engine, prefix + '/page.html', context)\n\n        // Write it to the disk\n        .then(function(tplOut) {\n            return writeFile(output, filePath, tplOut.getContent());\n        });\n    });\n}\n\nmodule.exports = onPage;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/website/onAsset.js":"var path = require('path');\nvar fs = require('../../utils/fs');\n\n/**\n    Copy an asset to the output folder\n\n    @param {Output} output\n    @param {Page} page\n*/\nfunction onAsset(output, asset) {\n    var book = output.getBook();\n    var options = output.getOptions();\n    var bookFS = book.getContentFS();\n\n    var outputFolder = options.get('root');\n    var outputPath = path.resolve(outputFolder, asset);\n\n    return fs.ensureFile(outputPath)\n    .then(function() {\n        return bookFS.readAsStream(asset)\n        .then(function(stream) {\n            return fs.writeStream(outputPath, stream);\n        });\n    })\n    .thenResolve(output);\n}\n\nmodule.exports = onAsset;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/ebook/index.js":"var extend = require('extend');\nvar WebsiteGenerator = require('../website');\n\nmodule.exports = extend({}, WebsiteGenerator, {\n    name: 'ebook',\n    Options: require('./options'),\n    onPage: require('./onPage'),\n    onFinish: require('./onFinish')\n});\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/ebook/options.js":"var Immutable = require('immutable');\n\nvar Options = Immutable.Record({\n    // Root folder for the output\n    root:               String(),\n\n    // Prefix for generation\n    prefix:             String('ebook'),\n\n    // Format to generate using ebook-convert\n    format:             String(),\n\n    // Force use of absolute urls (\"index.html\" instead of \"/\")\n    directoryIndex:     Boolean(false)\n});\n\nmodule.exports = Options;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/ebook/onPage.js":"var WebsiteGenerator = require('../website');\nvar Modifiers = require('../modifiers');\n\n/**\n    Write a page for ebook output\n\n    @param {Output} output\n    @param {Output}\n*/\nfunction onPage(output, page) {\n    var options = output.getOptions();\n\n    // Inline assets\n    return Modifiers.modifyHTML(page, [\n        Modifiers.inlineAssets(options.get('root'), page.getFile().getPath())\n    ])\n\n    // Write page using website generator\n    .then(function(resultPage) {\n        return WebsiteGenerator.onPage(output, resultPage);\n    });\n}\n\nmodule.exports = onPage;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/ebook/onFinish.js":"var path = require('path');\n\nvar WebsiteGenerator = require('../website');\nvar JSONUtils = require('../../json');\nvar Templating = require('../../templating');\nvar Promise = require('../../utils/promise');\nvar error = require('../../utils/error');\nvar command = require('../../utils/command');\nvar writeFile = require('../helper/writeFile');\n\nvar getConvertOptions = require('./getConvertOptions');\nvar SUMMARY_FILE = 'SUMMARY.html';\n\n/**\n    Write the SUMMARY.html\n\n    @param {Output}\n    @return {Output}\n*/\nfunction writeSummary(output) {\n    var options = output.getOptions();\n    var prefix = options.get('prefix');\n\n    var filePath = SUMMARY_FILE;\n    var engine = WebsiteGenerator.createTemplateEngine(output, filePath);\n    var context = JSONUtils.encodeOutput(output);\n\n    // Render the theme\n    return Templating.renderFile(engine, prefix + '/summary.html', context)\n\n    // Write it to the disk\n    .then(function(tplOut) {\n        return writeFile(output, filePath, tplOut.getContent());\n    });\n}\n\n/**\n    Generate the ebook file as \"index.pdf\"\n\n    @param {Output}\n    @return {Output}\n*/\nfunction runEbookConvert(output) {\n    var logger = output.getLogger();\n    var options = output.getOptions();\n    var format = options.get('format');\n    var outputFolder = output.getRoot();\n\n    if (!format) {\n        return Promise(output);\n    }\n\n    return getConvertOptions(output)\n    .then(function(options) {\n        var cmd = [\n            'ebook-convert',\n            path.resolve(outputFolder, SUMMARY_FILE),\n            path.resolve(outputFolder, 'index.' + format),\n            command.optionsToShellArgs(options)\n        ].join(' ');\n\n        return command.exec(cmd)\n        .progress(function(data) {\n            logger.debug(data);\n        })\n        .fail(function(err) {\n            if (err.code == 127) {\n                throw error.RequireInstallError({\n                    cmd: 'ebook-convert',\n                    install: 'Install it from Calibre: https://calibre-ebook.com'\n                });\n            }\n\n            throw error.EbookError(err);\n        });\n    })\n    .thenResolve(output);\n}\n\n/**\n    Finish the generation, generates the SUMMARY.html\n\n    @param {Output}\n    @return {Output}\n*/\nfunction onFinish(output) {\n    return writeSummary(output)\n    .then(runEbookConvert);\n}\n\nmodule.exports = onFinish;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/ebook/getConvertOptions.js":"var extend = require('extend');\n\nvar Promise = require('../../utils/promise');\nvar getPDFTemplate = require('./getPDFTemplate');\nvar getCoverPath = require('./getCoverPath');\n\n/**\n    Generate options for ebook-convert\n\n    @param {Output}\n    @return {Promise<Object>}\n*/\nfunction getConvertOptions(output) {\n    var options = output.getOptions();\n    var format = options.get('format');\n\n    var book = output.getBook();\n    var config = book.getConfig();\n\n    return Promise()\n    .then(function() {\n        var coverPath = getCoverPath(output);\n        var options = {\n            '--cover':                      coverPath,\n            '--title':                      config.getValue('title'),\n            '--comments':                   config.getValue('description'),\n            '--isbn':                       config.getValue('isbn'),\n            '--authors':                    config.getValue('author'),\n            '--language':                   book.getLanguage() || config.getValue('language'),\n            '--book-producer':              'GitBook',\n            '--publisher':                  'GitBook',\n            '--chapter':                    'descendant-or-self::*[contains(concat(\\' \\', normalize-space(@class), \\' \\'), \\' book-chapter \\')]',\n            '--level1-toc':                 'descendant-or-self::*[contains(concat(\\' \\', normalize-space(@class), \\' \\'), \\' book-chapter-1 \\')]',\n            '--level2-toc':                 'descendant-or-self::*[contains(concat(\\' \\', normalize-space(@class), \\' \\'), \\' book-chapter-2 \\')]',\n            '--level3-toc':                 'descendant-or-self::*[contains(concat(\\' \\', normalize-space(@class), \\' \\'), \\' book-chapter-3 \\')]',\n            '--max-levels':                 '1',\n            '--no-chapters-in-toc':         true,\n            '--breadth-first':              true,\n            '--dont-split-on-page-breaks':  format === 'epub'? true : undefined\n        };\n\n        if (format !== 'pdf') {\n            return options;\n        }\n\n        return Promise.all([\n            getPDFTemplate(output, 'header'),\n            getPDFTemplate(output, 'footer')\n        ])\n        .spread(function(headerTpl, footerTpl) {\n            var pdfOptions = config.getValue('pdf').toJS();\n\n            return options = extend(options, {\n                '--chapter-mark':           String(pdfOptions.chapterMark),\n                '--page-breaks-before':     String(pdfOptions.pageBreaksBefore),\n                '--margin-left':            String(pdfOptions.margin.left),\n                '--margin-right':           String(pdfOptions.margin.right),\n                '--margin-top':             String(pdfOptions.margin.top),\n                '--margin-bottom':          String(pdfOptions.margin.bottom),\n                '--pdf-default-font-size':  String(pdfOptions.fontSize),\n                '--pdf-mono-font-size':     String(pdfOptions.fontSize),\n                '--paper-size':             String(pdfOptions.paperSize),\n                '--pdf-page-numbers':       Boolean(pdfOptions.pageNumbers),\n                '--pdf-sans-family':        String(pdfOptions.fontFamily),\n                '--pdf-header-template':    headerTpl,\n                '--pdf-footer-template':    footerTpl\n            });\n        });\n    });\n}\n\n\nmodule.exports = getConvertOptions;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/ebook/getPDFTemplate.js":"var juice = require('juice');\n\nvar WebsiteGenerator = require('../website');\nvar JSONUtils = require('../../json');\nvar Templating = require('../../templating');\nvar Promise = require('../../utils/promise');\n\n\n/**\n    Generate PDF header/footer templates\n\n    @param {Output} output\n    @param {String} type\n    @return {String}\n*/\nfunction getPDFTemplate(output, type) {\n    var filePath = 'pdf_' + type + '.html';\n    var outputRoot = output.getRoot();\n    var engine = WebsiteGenerator.createTemplateEngine(output, filePath);\n\n    // Generate context\n    var context = JSONUtils.encodeOutput(output);\n    context.page = {\n        num: '_PAGENUM_',\n        title: '_SECTION_'\n    };\n\n    // Render the theme\n    return Templating.renderFile(engine, 'ebook/' + filePath, context)\n\n    // Inline css and assets\n    .then(function(tplOut) {\n        return Promise.nfcall(juice.juiceResources, tplOut.getContent(), {\n            webResources: {\n                relativeTo: outputRoot\n            }\n        });\n    });\n}\n\nmodule.exports = getPDFTemplate;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/ebook/getCoverPath.js":"var path = require('path');\nvar fs = require('../../utils/fs');\n\n/**\n    Resolve path to cover file to use\n\n    @param {Output}\n    @return {String}\n*/\nfunction getCoverPath(output) {\n    var outputRoot = output.getRoot();\n    var book = output.getBook();\n    var config = book.getConfig();\n    var coverName = config.getValue('cover', 'cover.jpg');\n\n    // Resolve to absolute\n    var cover = fs.pickFile(outputRoot, coverName);\n    if (cover) {\n        return cover;\n    }\n\n    // Multilingual? try parent folder\n    if (book.isLanguageBook()) {\n        cover = fs.pickFile(path.join(outputRoot, '..'), coverName);\n    }\n\n    return cover;\n}\n\nmodule.exports = getCoverPath;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/generateBook.js":"var path = require('path');\nvar Immutable = require('immutable');\n\nvar Output = require('../models/output');\nvar Promise = require('../utils/promise');\nvar fs = require('../utils/fs');\n\nvar callHook = require('./callHook');\nvar preparePlugins = require('./preparePlugins');\nvar preparePages = require('./preparePages');\nvar prepareAssets = require('./prepareAssets');\nvar generateAssets = require('./generateAssets');\nvar generatePages = require('./generatePages');\n\n/**\n * Process an output to generate the book\n *\n * @param {Generator} generator\n * @param {Output} output\n * @return {Promise<Output>}\n */\nfunction processOutput(generator, startOutput) {\n    return Promise(startOutput)\n    .then(preparePlugins)\n    .then(preparePages)\n    .then(prepareAssets)\n\n    .then(\n        callHook.bind(null,\n            'config',\n            function(output) {\n                var book = output.getBook();\n                var config = book.getConfig();\n                var values = config.getValues();\n\n                return values.toJS();\n            },\n            function(output, result) {\n                var book = output.getBook();\n                var config = book.getConfig();\n\n                config = config.updateValues(result);\n                book = book.set('config', config);\n                return output.set('book', book);\n            }\n        )\n    )\n\n    .then(\n        callHook.bind(null,\n            'init',\n            function(output) {\n                return {};\n            },\n            function(output) {\n                return output;\n            }\n        )\n    )\n\n    .then(function(output) {\n        if (!generator.onInit) {\n            return output;\n        }\n\n        return generator.onInit(output);\n    })\n\n    .then(generateAssets.bind(null, generator))\n    .then(generatePages.bind(null, generator))\n\n    .tap(function(output) {\n        var book = output.getBook();\n\n        if (!book.isMultilingual()) {\n            return;\n        }\n\n        var logger = book.getLogger();\n        var books = book.getBooks();\n        var outputRoot = output.getRoot();\n        var plugins = output.getPlugins();\n        var state = output.getState();\n        var options = output.getOptions();\n\n        return Promise.forEach(books, function(langBook) {\n            // Inherits plugins list, options and state\n            var langOptions = options.set('root', path.join(outputRoot, langBook.getLanguage()));\n            var langOutput = new Output({\n                book:       langBook,\n                options:    langOptions,\n                state:      state,\n                generator:  generator.name,\n                plugins:    plugins\n            });\n\n            logger.info.ln('');\n            logger.info.ln('generating language \"' + langBook.getLanguage() + '\"');\n            return processOutput(generator, langOutput);\n        });\n    })\n\n    .then(callHook.bind(null,\n        'finish:before',\n            function(output) {\n                return {};\n            },\n            function(output) {\n                return output;\n            }\n        )\n    )\n\n    .then(function(output) {\n        if (!generator.onFinish) {\n            return output;\n        }\n\n        return generator.onFinish(output);\n    })\n\n    .then(callHook.bind(null,\n        'finish',\n            function(output) {\n                return {};\n            },\n            function(output) {\n                return output;\n            }\n        )\n    );\n}\n\n/**\n * Generate a book using a generator.\n *\n * The overall process is:\n *     1. List and load plugins for this book\n *     2. Call hook \"config\"\n *     3. Call hook \"init\"\n *     4. Initialize generator\n *     5. List all assets and pages\n *     6. Copy all assets to output\n *     7. Generate all pages\n *     8. Call hook \"finish:before\"\n *     9. Finish generation\n *     10. Call hook \"finish\"\n *\n *\n * @param {Generator} generator\n * @param {Book} book\n * @param {Object} options\n * @return {Promise<Output>}\n */\nfunction generateBook(generator, book, options) {\n    options = generator.Options(options);\n    var state = generator.State? generator.State({}) : Immutable.Map();\n    var start = Date.now();\n\n    return Promise(\n        new Output({\n            book: book,\n            options: options,\n            state: state,\n            generator: generator.name\n        })\n    )\n\n    // Cleanup output folder\n    .then(function(output) {\n        var logger = output.getLogger();\n        var rootFolder = output.getRoot();\n\n        logger.debug.ln('cleanup folder \"' + rootFolder + '\"');\n        return fs.ensureFolder(rootFolder)\n            .thenResolve(output);\n    })\n\n    .then(processOutput.bind(null, generator))\n\n    // Log duration and end message\n    .then(function(output) {\n        var logger = output.getLogger();\n        var end = Date.now();\n        var duration = (end - start)/1000;\n\n        logger.info.ok('generation finished with success in ' + duration.toFixed(1) + 's !');\n\n        return output;\n    });\n}\n\nmodule.exports = generateBook;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/models/output.js":"var Immutable = require('immutable');\n\nvar Book = require('./book');\nvar LocationUtils = require('../utils/location');\n\nvar Output = Immutable.Record({\n    book:       Book(),\n\n    // Name of the generator being used\n    generator:  String(),\n\n    // Map of plugins to use (String -> Plugin)\n    plugins:    Immutable.OrderedMap(),\n\n    // Map pages to generation (String -> Page)\n    pages:      Immutable.OrderedMap(),\n\n    // List assets (String)\n    assets:     Immutable.List(),\n\n    // Option for the generation\n    options:    Immutable.Map(),\n\n    // Internal state for the generation\n    state:      Immutable.Map()\n});\n\nOutput.prototype.getBook = function() {\n    return this.get('book');\n};\n\nOutput.prototype.getGenerator = function() {\n    return this.get('generator');\n};\n\nOutput.prototype.getPlugins = function() {\n    return this.get('plugins');\n};\n\nOutput.prototype.getPages = function() {\n    return this.get('pages');\n};\n\nOutput.prototype.getOptions = function() {\n    return this.get('options');\n};\n\nOutput.prototype.getAssets = function() {\n    return this.get('assets');\n};\n\nOutput.prototype.getState = function() {\n    return this.get('state');\n};\n\n/**\n    Return a page byt its file path\n\n    @param {String} filePath\n    @return {Page|undefined}\n*/\nOutput.prototype.getPage = function(filePath) {\n    filePath = LocationUtils.normalize(filePath);\n\n    var pages = this.getPages();\n    return pages.get(filePath);\n};\n\n/**\n    Get root folder for output\n\n    @return {String}\n*/\nOutput.prototype.getRoot = function() {\n    return this.getOptions().get('root');\n};\n\n/**\n    Update state of output\n\n    @param {Map} newState\n    @return {Output}\n*/\nOutput.prototype.setState = function(newState) {\n    return this.set('state', newState);\n};\n\n/**\n    Update options\n\n    @param {Map} newOptions\n    @return {Output}\n*/\nOutput.prototype.setOptions = function(newOptions) {\n    return this.set('options', newOptions);\n};\n\n/**\n    Return logegr for this output (same as book)\n\n    @return {Logger}\n*/\nOutput.prototype.getLogger = function() {\n    return this.getBook().getLogger();\n};\n\nmodule.exports = Output;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/callHook.js":"var Promise = require('../utils/promise');\nvar timing = require('../utils/timing');\nvar Api = require('../api');\n\nfunction defaultGetArgument() {\n    return undefined;\n}\n\nfunction defaultHandleResult(output, result) {\n    return output;\n}\n\n/**\n    Call a \"global\" hook for an output\n\n    @param {String} name\n    @param {Function(Output) -> Mixed} getArgument\n    @param {Function(Output, result) -> Output} handleResult\n    @param {Output} output\n    @return {Promise<Output>}\n*/\nfunction callHook(name, getArgument, handleResult, output) {\n    getArgument = getArgument || defaultGetArgument;\n    handleResult = handleResult || defaultHandleResult;\n\n    var logger = output.getLogger();\n    var plugins = output.getPlugins();\n\n    logger.debug.ln('calling hook \"' + name + '\"');\n\n    // Create the JS context for plugins\n    var context = Api.encodeGlobal(output);\n\n    return timing.measure(\n        'call.hook.' + name,\n\n        // Get the arguments\n        Promise(getArgument(output))\n\n        // Call the hooks in serie\n        .then(function(arg) {\n            return Promise.reduce(plugins, function(prev, plugin) {\n                var hook = plugin.getHook(name);\n                if (!hook) {\n                    return prev;\n                }\n\n                return hook.call(context, prev);\n            }, arg);\n        })\n\n        // Handle final result\n        .then(function(result) {\n            output = Api.decodeGlobal(output, context);\n            return handleResult(output, result);\n        })\n    );\n}\n\nmodule.exports = callHook;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/preparePlugins.js":"var Plugins = require('../plugins');\nvar Promise = require('../utils/promise');\n\n/**\n * Load and setup plugins\n *\n * @param {Output}\n * @return {Promise<Output>}\n */\nfunction preparePlugins(output) {\n    var book = output.getBook();\n\n    return Promise()\n\n    // Only load plugins for main book\n    .then(function() {\n        if (book.isLanguageBook()) {\n            return output.getPlugins();\n        } else {\n            return Plugins.loadForBook(book);\n        }\n    })\n\n    // Update book's configuration using the plugins\n    .then(function(plugins) {\n        return Plugins.validateConfig(book, plugins)\n        .then(function(newBook) {\n            return output.merge({\n                book: newBook,\n                plugins: plugins\n            });\n        });\n    });\n}\n\nmodule.exports = preparePlugins;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/preparePages.js":"var Parse = require('../parse');\nvar Promise = require('../utils/promise');\n\n/**\n    List and prepare all pages\n\n    @param {Output}\n    @return {Promise<Output>}\n*/\nfunction preparePages(output) {\n    var book = output.getBook();\n    var logger = book.getLogger();\n\n    if (book.isMultilingual()) {\n        return Promise(output);\n    }\n\n    return Parse.parsePagesList(book)\n    .then(function(pages) {\n        logger.info.ln('found', pages.size, 'pages');\n\n        return output.set('pages', pages);\n    });\n}\n\nmodule.exports = preparePages;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/prepareAssets.js":"var Parse = require('../parse');\n\n/**\n    List all assets in the book\n\n    @param {Output}\n    @return {Promise<Output>}\n*/\nfunction prepareAssets(output) {\n    var book = output.getBook();\n    var pages = output.getPages();\n    var logger = output.getLogger();\n\n    return Parse.listAssets(book, pages)\n    .then(function(assets) {\n        logger.info.ln('found', assets.size, 'asset files');\n\n        return output.set('assets', assets);\n    });\n}\n\nmodule.exports = prepareAssets;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/generateAssets.js":"var Promise = require('../utils/promise');\n\n/**\n    Output all assets using a generator\n\n    @param {Generator} generator\n    @param {Output} output\n    @return {Promise<Output>}\n*/\nfunction generateAssets(generator, output) {\n    var assets = output.getAssets();\n    var logger = output.getLogger();\n\n    // Is generator ignoring assets?\n    if (!generator.onAsset) {\n        return Promise(output);\n    }\n\n    return Promise.reduce(assets, function(out, assetFile) {\n        logger.debug.ln('copy asset \"' + assetFile + '\"');\n\n        return generator.onAsset(out, assetFile);\n    }, output);\n}\n\nmodule.exports = generateAssets;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/generatePages.js":"var Promise = require('../utils/promise');\nvar generatePage = require('./generatePage');\n\n/**\n    Output all pages using a generator\n\n    @param {Generator} generator\n    @param {Output} output\n    @return {Promise<Output>}\n*/\nfunction generatePages(generator, output) {\n    var pages = output.getPages();\n    var logger = output.getLogger();\n\n    // Is generator ignoring assets?\n    if (!generator.onPage) {\n        return Promise(output);\n    }\n\n    return Promise.reduce(pages, function(out, page) {\n        var file = page.getFile();\n\n        logger.debug.ln('generate page \"' + file.getPath() + '\"');\n\n        return generatePage(out, page)\n        .then(function(resultPage) {\n            return generator.onPage(out, resultPage);\n        })\n        .fail(function(err) {\n            logger.error.ln('error while generating page \"' + file.getPath() + '\":');\n            throw err;\n        });\n    }, output);\n}\n\nmodule.exports = generatePages;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/generatePage.js":"var path = require('path');\n\nvar Promise = require('../utils/promise');\nvar error = require('../utils/error');\nvar timing = require('../utils/timing');\n\nvar Templating = require('../templating');\nvar JSONUtils = require('../json');\nvar createTemplateEngine = require('./createTemplateEngine');\nvar callPageHook = require('./callPageHook');\n\n/**\n * Prepare and generate HTML for a page\n *\n * @param {Output} output\n * @param {Page} page\n * @return {Promise<Page>}\n */\nfunction generatePage(output, page) {\n    var book = output.getBook();\n    var engine = createTemplateEngine(output);\n\n    return timing.measure(\n        'page.generate',\n        Promise(page)\n        .then(function(resultPage) {\n            var file = resultPage.getFile();\n            var filePath = file.getPath();\n            var parser = file.getParser();\n            var context = JSONUtils.encodeOutputWithPage(output, resultPage);\n\n            if (!parser) {\n                return Promise.reject(error.FileNotParsableError({\n                    filename: filePath\n                }));\n            }\n\n            // Call hook \"page:before\"\n            return callPageHook('page:before', output, resultPage)\n\n            // Escape code blocks with raw tags\n            .then(function(currentPage) {\n                return parser.preparePage(currentPage.getContent());\n            })\n\n            // Render templating syntax\n            .then(function(content) {\n                var absoluteFilePath = path.join(book.getContentRoot(), filePath);\n                return Templating.render(engine, absoluteFilePath, content, context);\n            })\n\n            .then(function(output) {\n                var content = output.getContent();\n\n                return parser.parsePage(content)\n                .then(function(result) {\n                    return output.setContent(result.content);\n                });\n            })\n\n            // Post processing for templating syntax\n            .then(function(output) {\n                return Templating.postRender(engine, output);\n            })\n\n            // Return new page\n            .then(function(content) {\n                return resultPage.set('content', content);\n            })\n\n            // Call final hook\n            .then(function(currentPage) {\n                return callPageHook('page', output, currentPage);\n            });\n        })\n    );\n}\n\nmodule.exports = generatePage;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/createTemplateEngine.js":"var Templating = require('../templating');\nvar TemplateEngine = require('../models/templateEngine');\n\nvar Api = require('../api');\nvar Plugins = require('../plugins');\n\nvar defaultBlocks = require('../constants/defaultBlocks');\nvar defaultFilters = require('../constants/defaultFilters');\n\n/**\n    Create template engine for an output.\n    It adds default filters/blocks, then add the ones from plugins\n\n    @param {Output} output\n    @return {TemplateEngine}\n*/\nfunction createTemplateEngine(output) {\n    var plugins = output.getPlugins();\n    var book = output.getBook();\n    var rootFolder = book.getContentRoot();\n    var logger = book.getLogger();\n\n    var filters = Plugins.listFilters(plugins);\n    var blocks = Plugins.listBlocks(plugins);\n\n    // Extend with default\n    blocks = defaultBlocks.merge(blocks);\n    filters = defaultFilters.merge(filters);\n\n    // Create loader\n    var transformFn = Templating.replaceShortcuts.bind(null, blocks);\n    var loader = new Templating.ConrefsLoader(rootFolder, transformFn, logger);\n\n    // Create API context\n    var context = Api.encodeGlobal(output);\n\n    return new TemplateEngine({\n        filters:    filters,\n        blocks:     blocks,\n        loader:     loader,\n        context:    context\n    });\n}\n\nmodule.exports = createTemplateEngine;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/output/callPageHook.js":"var Api = require('../api');\nvar callHook = require('./callHook');\n\n/**\n    Call a hook for a specific page\n\n    @param {String} name\n    @param {Output} output\n    @param {Page} page\n    @return {Promise<Page>}\n*/\nfunction callPageHook(name, output, page) {\n    return callHook(\n        name,\n\n        function(out) {\n            return Api.encodePage(out, page);\n        },\n\n        function(out, result) {\n            return Api.decodePage(out, page, result);\n        },\n\n        output\n    );\n}\n\nmodule.exports = callPageHook;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/cli/index.js":"var buildEbook = require('./buildEbook');\n\nmodule.exports = [\n    require('./build'),\n    require('./serve'),\n    require('./install'),\n    require('./parse'),\n    require('./init'),\n    buildEbook('pdf'),\n    buildEbook('epub'),\n    buildEbook('mobi')\n];\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/cli/buildEbook.js":"var path = require('path');\nvar tmp = require('tmp');\n\nvar Promise = require('../utils/promise');\nvar fs = require('../utils/fs');\nvar Parse = require('../parse');\nvar Output = require('../output');\n\nvar options = require('./options');\nvar getBook = require('./getBook');\n\n\nmodule.exports = function(format) {\n    return {\n        name: (format + ' [book] [output]'),\n        description: 'build a book into an ebook file',\n        options: [\n            options.log\n        ],\n        exec: function(args, kwargs) {\n            var extension = '.' + format;\n\n            // Output file will be stored in\n            var outputFile = args[1] || ('book' + extension);\n\n            // Create temporary directory\n            var outputFolder = tmp.dirSync().name;\n\n            var book = getBook(args, kwargs);\n            var logger = book.getLogger();\n            var Generator = Output.getGenerator('ebook');\n\n            return Parse.parseBook(book)\n            .then(function(resultBook) {\n                return Output.generate(Generator, resultBook, {\n                    root: outputFolder,\n                    format: format\n                });\n            })\n\n            // Extract ebook file\n            .then(function(output) {\n                var book = output.getBook();\n                var languages = book.getLanguages();\n\n                if (book.isMultilingual()) {\n                    return Promise.forEach(languages.getList(), function(lang) {\n                        var langID = lang.getID();\n\n                        var langOutputFile = path.join(\n                            path.dirname(outputFile),\n                            path.basename(outputFile, extension) + '_' + langID + extension\n                        );\n\n                        return fs.copy(\n                            path.resolve(outputFolder, langID, 'index' + extension),\n                            langOutputFile\n                        );\n                    })\n                    .thenResolve(languages.getCount());\n                } else {\n                    return fs.copy(\n                        path.resolve(outputFolder, 'index' + extension),\n                        outputFile\n                    ).thenResolve(1);\n                }\n            })\n\n            // Log end\n            .then(function(count) {\n                logger.info.ok(count + ' file(s) generated');\n\n                logger.debug('cleaning up... ');\n                return logger.debug.promise(fs.rmDir(outputFolder));\n            });\n        }\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/cli/options.js":"var Logger = require('../utils/logger');\n\nvar logOptions = {\n    name: 'log',\n    description: 'Minimum log level to display',\n    values: Logger.LEVELS\n        .keySeq()\n        .map(function(s) {\n            return s.toLowerCase();\n        }).toJS(),\n    defaults: 'info'\n};\n\nvar formatOption = {\n    name: 'format',\n    description: 'Format to build to',\n    values: ['website', 'json', 'ebook'],\n    defaults: 'website'\n};\n\nvar timingOption = {\n    name: 'timing',\n    description: 'Print timing debug information',\n    defaults: false\n};\n\nmodule.exports = {\n    log: logOptions,\n    format: formatOption,\n    timing: timingOption\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/cli/getBook.js":"var path = require('path');\nvar Book = require('../models/book');\nvar createNodeFS = require('../fs/node');\n\n/**\n    Return a book instance to work on from\n    command line args/kwargs\n\n    @param {Array} args\n    @param {Object} kwargs\n    @return {Book}\n*/\nfunction getBook(args, kwargs) {\n    var input = path.resolve(args[0] || process.cwd());\n    var logLevel = kwargs.log;\n\n    var fs = createNodeFS(input);\n    var book = Book.createForFS(fs);\n\n    return book.setLogLevel(logLevel);\n}\n\nmodule.exports = getBook;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/cli/build.js":"var Parse = require('../parse');\nvar Output = require('../output');\nvar timing = require('../utils/timing');\n\nvar options = require('./options');\nvar getBook = require('./getBook');\nvar getOutputFolder = require('./getOutputFolder');\n\n\nmodule.exports = {\n    name: 'build [book] [output]',\n    description: 'build a book',\n    options: [\n        options.log,\n        options.format,\n        options.timing\n    ],\n    exec: function(args, kwargs) {\n        var book = getBook(args, kwargs);\n        var outputFolder = getOutputFolder(args);\n\n        var Generator = Output.getGenerator(kwargs.format);\n\n        return Parse.parseBook(book)\n        .then(function(resultBook) {\n            return Output.generate(Generator, resultBook, {\n                root: outputFolder\n            });\n        })\n        .fin(function() {\n            if (kwargs.timing) timing.dump(book.getLogger());\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/cli/getOutputFolder.js":"var path = require('path');\n\n/**\n    Return path to output folder\n\n    @param {Array} args\n    @return {String}\n*/\nfunction getOutputFolder(args) {\n    var bookRoot = path.resolve(args[0] || process.cwd());\n    var defaultOutputRoot = path.join(bookRoot, '_book');\n    var outputFolder = args[1]? path.resolve(process.cwd(), args[1]) : defaultOutputRoot;\n\n    return outputFolder;\n}\n\nmodule.exports = getOutputFolder;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/cli/serve.js":"/* eslint-disable no-console */\n\nvar tinylr = require('tiny-lr');\nvar open = require('open');\n\nvar Parse = require('../parse');\nvar Output = require('../output');\nvar ConfigModifier = require('../modifiers').Config;\n\nvar Promise = require('../utils/promise');\n\nvar options = require('./options');\nvar getBook = require('./getBook');\nvar getOutputFolder = require('./getOutputFolder');\nvar Server = require('./server');\nvar watch = require('./watch');\n\nvar server, lrServer, lrPath;\n\nfunction waitForCtrlC() {\n    var d = Promise.defer();\n\n    process.on('SIGINT', function() {\n        d.resolve();\n    });\n\n    return d.promise;\n}\n\n\nfunction generateBook(args, kwargs) {\n    var port = kwargs.port;\n    var outputFolder = getOutputFolder(args);\n    var book = getBook(args, kwargs);\n    var Generator = Output.getGenerator(kwargs.format);\n    var browser = kwargs['browser'];\n\n    var hasWatch = kwargs['watch'];\n    var hasLiveReloading = kwargs['live'];\n    var hasOpen = kwargs['open'];\n\n    // Stop server if running\n    if (server.isRunning()) console.log('Stopping server');\n\n    return server.stop()\n    .then(function() {\n        return Parse.parseBook(book)\n        .then(function(resultBook) {\n            if (hasLiveReloading) {\n                // Enable livereload plugin\n                var config = resultBook.getConfig();\n                config = ConfigModifier.addPlugin(config, 'livereload');\n                resultBook = resultBook.set('config', config);\n            }\n\n            return Output.generate(Generator, resultBook, {\n                root: outputFolder\n            });\n        });\n    })\n    .then(function() {\n        console.log();\n        console.log('Starting server ...');\n        return server.start(outputFolder, port);\n    })\n    .then(function() {\n        console.log('Serving book on http://localhost:'+port);\n\n        if (lrPath && hasLiveReloading) {\n            // trigger livereload\n            lrServer.changed({\n                body: {\n                    files: [lrPath]\n                }\n            });\n        }\n\n        if (hasOpen) {\n            open('http://localhost:'+port, browser);\n        }\n    })\n    .then(function() {\n        if (!hasWatch) {\n            return waitForCtrlC();\n        }\n\n        return watch(book.getRoot())\n        .then(function(filepath) {\n            // set livereload path\n            lrPath = filepath;\n            console.log('Restart after change in file', filepath);\n            console.log('');\n            return generateBook(args, kwargs);\n        });\n    });\n}\n\nmodule.exports = {\n    name: 'serve [book] [output]',\n    description: 'serve the book as a website for testing',\n    options: [\n        {\n            name: 'port',\n            description: 'Port for server to listen on',\n            defaults: 4000\n        },\n        {\n            name: 'lrport',\n            description: 'Port for livereload server to listen on',\n            defaults: 35729\n        },\n        {\n            name: 'watch',\n            description: 'Enable file watcher and live reloading',\n            defaults: true\n        },\n        {\n            name: 'live',\n            description: 'Enable live reloading',\n            defaults: true\n        },\n        {\n            name: 'open',\n            description: 'Enable opening book in browser',\n            defaults: false\n        },\n        {\n            name: 'browser',\n            description: 'Specify browser for opening book',\n            defaults: ''\n        },\n        options.log,\n        options.format\n    ],\n    exec: function(args, kwargs) {\n        server = new Server();\n        var hasWatch = kwargs['watch'];\n        var hasLiveReloading = kwargs['live'];\n\n        return Promise()\n        .then(function() {\n            if (!hasWatch || !hasLiveReloading) {\n                return;\n            }\n\n            lrServer = tinylr({});\n            return Promise.nfcall(lrServer.listen.bind(lrServer), kwargs.lrport)\n            .then(function() {\n                console.log('Live reload server started on port:', kwargs.lrport);\n                console.log('Press CTRL+C to quit ...');\n                console.log('');\n\n            });\n        })\n        .then(function() {\n            return generateBook(args, kwargs);\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/cli/server.js":"var events = require('events');\nvar http = require('http');\nvar send = require('send');\nvar util = require('util');\nvar url = require('url');\n\nvar Promise = require('../utils/promise');\n\nfunction Server() {\n    this.running = null;\n    this.dir = null;\n    this.port = 0;\n    this.sockets = [];\n}\nutil.inherits(Server, events.EventEmitter);\n\n/**\n    Return true if the server is running\n\n    @return {Boolean}\n*/\nServer.prototype.isRunning = function() {\n    return !!this.running;\n};\n\n/**\n    Stop the server\n\n    @return {Promise}\n*/\nServer.prototype.stop = function() {\n    var that = this;\n    if (!this.isRunning()) return Promise();\n\n    var d = Promise.defer();\n    this.running.close(function(err) {\n        that.running = null;\n        that.emit('state', false);\n\n        if (err) d.reject(err);\n        else d.resolve();\n    });\n\n    for (var i = 0; i < this.sockets.length; i++) {\n        this.sockets[i].destroy();\n    }\n\n    return d.promise;\n};\n\n/**\n    Start the server\n\n    @return {Promise}\n*/\nServer.prototype.start = function(dir, port) {\n    var that = this, pre = Promise();\n    port = port || 8004;\n\n    if (that.isRunning()) pre = this.stop();\n    return pre\n    .then(function() {\n        var d = Promise.defer();\n\n        that.running = http.createServer(function(req, res){\n            // Render error\n            function error(err) {\n                res.statusCode = err.status || 500;\n                res.end(err.message);\n            }\n\n            // Redirect to directory's index.html\n            function redirect() {\n                var resultURL = urlTransform(req.url, function(parsed) {\n                    parsed.pathname += '/';\n                    return parsed;\n                });\n\n                res.statusCode = 301;\n                res.setHeader('Location', resultURL);\n                res.end('Redirecting to ' + resultURL);\n            }\n\n            res.setHeader('X-Current-Location', req.url);\n\n            // Send file\n            send(req, url.parse(req.url).pathname, {\n                root: dir\n            })\n            .on('error', error)\n            .on('directory', redirect)\n            .pipe(res);\n        });\n\n        that.running.on('connection', function (socket) {\n            that.sockets.push(socket);\n            socket.setTimeout(4000);\n            socket.on('close', function () {\n                that.sockets.splice(that.sockets.indexOf(socket), 1);\n            });\n        });\n\n        that.running.listen(port, function(err) {\n            if (err) return d.reject(err);\n\n            that.port = port;\n            that.dir = dir;\n            that.emit('state', true);\n            d.resolve();\n        });\n\n        return d.promise;\n    });\n};\n\n/**\n    urlTransform is a helper function that allows a function to transform\n    a url string in it's parsed form and returns the new url as a string\n\n    @param {String} uri\n    @param {Function} fn\n    @return {String}\n*/\nfunction urlTransform(uri, fn) {\n    return url.format(fn(url.parse(uri)));\n}\n\nmodule.exports = Server;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/cli/watch.js":"var path = require('path');\nvar chokidar = require('chokidar');\n\nvar Promise = require('../utils/promise');\nvar parsers = require('../parsers');\n\n/**\n    Watch a folder and resolve promise once a file is modified\n\n    @param {String} dir\n    @return {Promise}\n*/\nfunction watch(dir) {\n    var d = Promise.defer();\n    dir = path.resolve(dir);\n\n    var toWatch = [\n        'book.json', 'book.js', '_layouts/**'\n    ];\n\n    // Watch all parsable files\n    parsers.extensions.forEach(function(ext) {\n        toWatch.push('**/*'+ext);\n    });\n\n    var watcher = chokidar.watch(toWatch, {\n        cwd: dir,\n        ignored: '_book/**',\n        ignoreInitial: true\n    });\n\n    watcher.once('all', function(e, filepath) {\n        watcher.close();\n\n        d.resolve(filepath);\n    });\n    watcher.once('error', function(err) {\n        watcher.close();\n\n        d.reject(err);\n    });\n\n    return d.promise;\n}\n\nmodule.exports = watch;\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/cli/install.js":"var options = require('./options');\nvar getBook = require('./getBook');\n\nvar Parse = require('../parse');\nvar Plugins = require('../plugins');\n\nmodule.exports = {\n    name: 'install [book]',\n    description: 'install all plugins dependencies',\n    options: [\n        options.log\n    ],\n    exec: function(args, kwargs) {\n        var book = getBook(args, kwargs);\n\n        return Parse.parseConfig(book)\n        .then(function(resultBook) {\n            return Plugins.installPlugins(resultBook);\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/cli/parse.js":"var options = require('./options');\nvar getBook = require('./getBook');\n\nvar Parse = require('../parse');\n\nfunction printBook(book) {\n    var logger = book.getLogger();\n\n    var config = book.getConfig();\n    var configFile = config.getFile();\n\n    var summary = book.getSummary();\n    var summaryFile = summary.getFile();\n\n    var readme = book.getReadme();\n    var readmeFile = readme.getFile();\n\n    var glossary = book.getGlossary();\n    var glossaryFile = glossary.getFile();\n\n    if (configFile.exists()) {\n        logger.info.ln('Configuration file is', configFile.getPath());\n    }\n\n    if (readmeFile.exists()) {\n        logger.info.ln('Introduction file is', readmeFile.getPath());\n    }\n\n    if (glossaryFile.exists()) {\n        logger.info.ln('Glossary file is', glossaryFile.getPath());\n    }\n\n    if (summaryFile.exists()) {\n        logger.info.ln('Table of Contents file is', summaryFile.getPath());\n    }\n}\n\nfunction printMultingualBook(book) {\n    var logger = book.getLogger();\n    var languages = book.getLanguages();\n    var books = book.getBooks();\n\n    logger.info.ln(languages.size + ' languages');\n\n    languages.forEach(function(lang) {\n        logger.info.ln('Language:', lang.getTitle());\n        printBook(books.get(lang.getID()));\n        logger.info.ln('');\n    });\n}\n\nmodule.exports = {\n    name: 'parse [book]',\n    description: 'parse and print debug information about a book',\n    options: [\n        options.log\n    ],\n    exec: function(args, kwargs) {\n        var book = getBook(args, kwargs);\n        var logger = book.getLogger();\n\n        return Parse.parseBook(book)\n        .then(function(resultBook) {\n            var rootFolder = book.getRoot();\n            var contentFolder = book.getContentRoot();\n\n            logger.info.ln('Book located in:', rootFolder);\n            if (contentFolder != rootFolder) {\n                logger.info.ln('Content located in:', contentFolder);\n            }\n\n            if (resultBook.isMultilingual()) {\n                printMultingualBook(resultBook);\n            } else {\n                printBook(resultBook);\n            }\n        });\n    }\n};\n","/home/travis/build/npmtest/node-npmtest-gitbook/gitbook/lib/cli/init.js":"var path = require('path');\n\nvar options = require('./options');\nvar initBook = require('../init');\n\nmodule.exports = {\n    name: 'init [book]',\n    description: 'setup and create files for chapters',\n    options: [\n        options.log\n    ],\n    exec: function(args, kwargs) {\n        var bookRoot = path.resolve(process.cwd(), args[0] || './');\n\n        return initBook(bookRoot);\n    }\n};\n"}